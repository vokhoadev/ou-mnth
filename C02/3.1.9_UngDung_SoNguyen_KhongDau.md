# 3.1.9 ỨNG DỤNG SỐ NGUYÊN KHÔNG DẤU

## Mô tả dạng bài tập
Ứng dụng số nguyên không dấu trong các bài toán thực tế: đếm, chỉ số mảng, địa chỉ bộ nhớ, cờ trạng thái.

## Phương pháp giải

### Phương pháp 1: Đếm và chỉ số
1. **Sử dụng số nguyên không dấu** để đếm
2. **Chỉ số mảng** từ 0 đến n-1
3. **Kiểm tra** phạm vi giá trị

### Phương pháp 2: Địa chỉ bộ nhớ
1. **Địa chỉ bộ nhớ** là số nguyên không dấu
2. **Tính toán** địa chỉ tương đối
3. **Kiểm tra** tràn số

## Bảng ứng dụng:
| Ứng dụng | Số bit | Phạm vi | Ví dụ |
|----------|--------|---------|-------|
| Đếm | 8 | 0-255 | Loop counter |
| Chỉ số mảng | 16 | 0-65535 | Array index |
| Địa chỉ bộ nhớ | 32 | 0-4294967295 | Memory address |
| Cờ trạng thái | 1 | 0-1 | Boolean flag |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Đếm từ 0 đến 10 bằng số nguyên 8 bit không dấu

**Lời giải:**
```
Bước 1: Khởi tạo biến đếm
count = 0 (8 bit không dấu)

Bước 2: Vòng lặp đếm
count = 0: 0 ≤ 10 ✓
count = 1: 1 ≤ 10 ✓
count = 2: 2 ≤ 10 ✓
count = 3: 3 ≤ 10 ✓
count = 4: 4 ≤ 10 ✓
count = 5: 5 ≤ 10 ✓
count = 6: 6 ≤ 10 ✓
count = 7: 7 ≤ 10 ✓
count = 8: 8 ≤ 10 ✓
count = 9: 9 ≤ 10 ✓
count = 10: 10 ≤ 10 ✓
count = 11: 11 > 10 ✗ (dừng)

Bước 3: Kết quả
Đếm được từ 0 đến 10 (11 lần)

Kết quả: Số nguyên 8 bit không dấu có thể đếm từ 0 đến 10
```

### Bài 2: Chỉ số mảng có 100 phần tử bằng số nguyên 16 bit không dấu

**Lời giải:**
```
Bước 1: Xác định kích thước mảng
n = 100 phần tử

Bước 2: Xác định phạm vi chỉ số
0 ≤ index ≤ n-1
0 ≤ index ≤ 99

Bước 3: Kiểm tra phạm vi 16 bit
16 bit: 0 ≤ giá trị ≤ 65535
99 ≤ 65535 ✓

Bước 4: Kết quả
Số nguyên 16 bit không dấu có thể làm chỉ số mảng 100 phần tử

Kết quả: Chỉ số mảng từ 0 đến 99 (16 bit không dấu)
```

### Bài 3: Địa chỉ bộ nhớ từ 0x1000 đến 0x2000 bằng số nguyên 32 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển địa chỉ sang thập phân
0x1000 = 4096₁₀
0x2000 = 8192₁₀

Bước 2: Tính kích thước vùng nhớ
8192 - 4096 = 4096 bytes

Bước 3: Kiểm tra phạm vi 32 bit
32 bit: 0 ≤ giá trị ≤ 4294967295
8192 ≤ 4294967295 ✓

Bước 4: Kết quả
Số nguyên 32 bit không dấu có thể biểu diễn địa chỉ từ 0x1000 đến 0x2000

Kết quả: Địa chỉ bộ nhớ từ 4096 đến 8192 (32 bit không dấu)
```

### Bài 4: Cờ trạng thái 8 bit cho 8 thiết bị

**Lời giải:**
```
Bước 1: Xác định số thiết bị
n = 8 thiết bị

Bước 2: Xác định số bit cần thiết
8 bit = 8 cờ trạng thái

Bước 3: Mã hóa trạng thái
Bit 0: Thiết bị 0 (0=OFF, 1=ON)
Bit 1: Thiết bị 1 (0=OFF, 1=ON)
Bit 2: Thiết bị 2 (0=OFF, 1=ON)
Bit 3: Thiết bị 3 (0=OFF, 1=ON)
Bit 4: Thiết bị 4 (0=OFF, 1=ON)
Bit 5: Thiết bị 5 (0=OFF, 1=ON)
Bit 6: Thiết bị 6 (0=OFF, 1=ON)
Bit 7: Thiết bị 7 (0=OFF, 1=ON)

Bước 4: Ví dụ
0x55 = 01010101₂ → Thiết bị 0,2,4,6 ON; 1,3,5,7 OFF

Kết quả: 8 bit không dấu có thể quản lý 8 thiết bị
```

### Bài 5: Đếm số lần lặp tối đa với số nguyên 8 bit không dấu

**Lời giải:**
```
Bước 1: Xác định phạm vi 8 bit
8 bit: 0 ≤ giá trị ≤ 255

Bước 2: Tính số lần lặp tối đa
Số lần lặp tối đa = 255

Bước 3: Kiểm tra tràn số
255 + 1 = 256 > 255 ✗ (tràn số)

Bước 4: Kết quả
Số nguyên 8 bit không dấu có thể đếm tối đa 255 lần

Kết quả: Số lần lặp tối đa là 255 (8 bit không dấu)
```

### Bài 6: Chỉ số mảng 2D có kích thước 100x100 bằng số nguyên 16 bit không dấu

**Lời giải:**
```
Bước 1: Xác định kích thước mảng 2D
rows = 100, cols = 100
total_elements = 100 × 100 = 10000

Bước 2: Xác định phạm vi chỉ số
0 ≤ index ≤ 9999

Bước 3: Kiểm tra phạm vi 16 bit
16 bit: 0 ≤ giá trị ≤ 65535
9999 ≤ 65535 ✓

Bước 4: Tính chỉ số 2D
index = row × cols + col
0 ≤ row ≤ 99, 0 ≤ col ≤ 99

Bước 5: Kết quả
Số nguyên 16 bit không dấu có thể làm chỉ số mảng 2D 100x100

Kết quả: Chỉ số mảng 2D từ 0 đến 9999 (16 bit không dấu)
```

### Bài 7: Địa chỉ bộ nhớ từ 0x00000000 đến 0xFFFFFFFF bằng số nguyên 32 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển địa chỉ sang thập phân
0x00000000 = 0₁₀
0xFFFFFFFF = 4294967295₁₀

Bước 2: Tính kích thước vùng nhớ
4294967295 - 0 = 4294967295 bytes = 4GB

Bước 3: Kiểm tra phạm vi 32 bit
32 bit: 0 ≤ giá trị ≤ 4294967295
4294967295 ≤ 4294967295 ✓

Bước 4: Kết quả
Số nguyên 32 bit không dấu có thể biểu diễn địa chỉ từ 0x00000000 đến 0xFFFFFFFF

Kết quả: Địa chỉ bộ nhớ từ 0 đến 4GB (32 bit không dấu)
```

### Bài 8: Cờ trạng thái 16 bit cho 16 thiết bị

**Lời giải:**
```
Bước 1: Xác định số thiết bị
n = 16 thiết bị

Bước 2: Xác định số bit cần thiết
16 bit = 16 cờ trạng thái

Bước 3: Mã hóa trạng thái
Bit 0-15: Thiết bị 0-15 (0=OFF, 1=ON)

Bước 4: Ví dụ
0xAAAA = 1010101010101010₂ → Thiết bị chẵn ON, lẻ OFF

Bước 5: Kết quả
16 bit không dấu có thể quản lý 16 thiết bị

Kết quả: 16 bit không dấu có thể quản lý 16 thiết bị
```

### Bài 9: Đếm số lần lặp tối đa với số nguyên 16 bit không dấu

**Lời giải:**
```
Bước 1: Xác định phạm vi 16 bit
16 bit: 0 ≤ giá trị ≤ 65535

Bước 2: Tính số lần lặp tối đa
Số lần lặp tối đa = 65535

Bước 3: Kiểm tra tràn số
65535 + 1 = 65536 > 65535 ✗ (tràn số)

Bước 4: Kết quả
Số nguyên 16 bit không dấu có thể đếm tối đa 65535 lần

Kết quả: Số lần lặp tối đa là 65535 (16 bit không dấu)
```

### Bài 10: Chỉ số mảng 3D có kích thước 50x50x50 bằng số nguyên 32 bit không dấu

**Lời giải:**
```
Bước 1: Xác định kích thước mảng 3D
x = 50, y = 50, z = 50
total_elements = 50 × 50 × 50 = 125000

Bước 2: Xác định phạm vi chỉ số
0 ≤ index ≤ 124999

Bước 3: Kiểm tra phạm vi 32 bit
32 bit: 0 ≤ giá trị ≤ 4294967295
124999 ≤ 4294967295 ✓

Bước 4: Tính chỉ số 3D
index = x × y × z + y × z + z
0 ≤ x ≤ 49, 0 ≤ y ≤ 49, 0 ≤ z ≤ 49

Bước 5: Kết quả
Số nguyên 32 bit không dấu có thể làm chỉ số mảng 3D 50x50x50

Kết quả: Chỉ số mảng 3D từ 0 đến 124999 (32 bit không dấu)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Đếm từ 0 đến 5 bằng số nguyên 4 bit không dấu
2. Chỉ số mảng có 10 phần tử bằng số nguyên 8 bit không dấu
3. Địa chỉ bộ nhớ từ 0x0000 đến 0x1000 bằng số nguyên 16 bit không dấu
4. Cờ trạng thái 4 bit cho 4 thiết bị
5. Đếm số lần lặp tối đa với số nguyên 4 bit không dấu
6. Chỉ số mảng có 50 phần tử bằng số nguyên 8 bit không dấu
7. Địa chỉ bộ nhớ từ 0x0000 đến 0x2000 bằng số nguyên 16 bit không dấu
8. Cờ trạng thái 8 bit cho 8 thiết bị
9. Đếm số lần lặp tối đa với số nguyên 8 bit không dấu
10. Chỉ số mảng có 100 phần tử bằng số nguyên 16 bit không dấu

### Cấp độ trung bình (11-15):
11. Địa chỉ bộ nhớ từ 0x00000000 đến 0x10000000 bằng số nguyên 32 bit không dấu
12. Cờ trạng thái 16 bit cho 16 thiết bị
13. Đếm số lần lặp tối đa với số nguyên 16 bit không dấu
14. Chỉ số mảng 2D có kích thước 50x50 bằng số nguyên 16 bit không dấu
15. Địa chỉ bộ nhớ từ 0x00000000 đến 0x20000000 bằng số nguyên 32 bit không dấu

### Cấp độ nâng cao (16-20):
16. Cờ trạng thái 32 bit cho 32 thiết bị
17. Đếm số lần lặp tối đa với số nguyên 32 bit không dấu
18. Chỉ số mảng 3D có kích thước 100x100x100 bằng số nguyên 32 bit không dấu
19. Địa chỉ bộ nhớ từ 0x00000000 đến 0x80000000 bằng số nguyên 32 bit không dấu
20. Cờ trạng thái 64 bit cho 64 thiết bị

---

##  MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Đếm**: sử dụng số nguyên không dấu
- **Chỉ số mảng**: từ 0 đến n-1
- **Địa chỉ bộ nhớ**: số nguyên không dấu
- **Cờ trạng thái**: 1 bit = 1 thiết bị

### LƯU Ý QUAN TRỌNG:
- **Không có bit dấu** (luôn dương)
- **Phạm vi**: 0 đến 2^n - 1
- **Số bit cố định** (không thay đổi)
- **Kiểm tra** tràn số trước khi sử dụng

### CÁCH KIỂM TRA:
- **Tính toán** phạm vi trước
- **So sánh** với yêu cầu
- **Kiểm tra** tràn số nếu cần
- **Sử dụng** máy tính để verify

### CÁC ỨNG DỤNG ĐẶC BIỆT:
- **Đếm**: loop counter, array size
- **Chỉ số**: array index, matrix index
- **Địa chỉ**: memory address, pointer
- **Cờ**: status flags, device states

### PHƯƠNG PHÁP NHANH:
1. **Xác định** ứng dụng
2. **Tính** phạm vi cần thiết
3. **Chọn** số bit phù hợp
4. **Kiểm tra** tràn số

### VÍ DỤ ỨNG DỤNG:
```cpp
// Đếm với số nguyên không dấu
void countWithUnsigned() {
    unsigned int count = 0;
    while (count < 100) {
        // Xử lý
        count++;
    }
}

// Chỉ số mảng với số nguyên không dấu
void arrayIndexWithUnsigned() {
    int array[100];
    for (unsigned int i = 0; i < 100; i++) {
        array[i] = i;
    }
}

// Địa chỉ bộ nhớ với số nguyên không dấu
void memoryAddressWithUnsigned() {
    unsigned int baseAddress = 0x1000;
    unsigned int offset = 0x100;
    unsigned int finalAddress = baseAddress + offset;
}

// Cờ trạng thái với số nguyên không dấu
void statusFlagsWithUnsigned() {
    unsigned int flags = 0;
    flags |= (1 << 0); // Set bit 0
    flags |= (1 << 1); // Set bit 1
    flags &= ~(1 << 0); // Clear bit 0
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Unsigned integer types
- **Assembly**: Unsigned arithmetic
- **Memory addressing**: Address calculations
- **Counters**: Loop counters, array indices
- **Flags**: Boolean flags, status bits

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 3.1: Biểu diễn số nguyên không dấu
