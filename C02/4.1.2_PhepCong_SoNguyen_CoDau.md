# 4.1.2 PHÉP CỘNG SỐ NGUYÊN CÓ DẤU

## Mô tả dạng bài tập
Thực hiện phép cộng giữa hai số nguyên có dấu và xử lý tràn số (overflow).

**Lưu ý quan trọng:** File này mô tả phép cộng số có dấu sử dụng phương pháp **SIGNED MAGNITUDE** (bit dấu + phần trị). Để thực hiện phép cộng số có dấu bằng phương pháp **TWO'S COMPLEMENT** (bù 2 - chuẩn máy tính), xem file 4.2.5.

## Phương pháp giải

### Phương pháp 1: Cộng trực tiếp
1. **Cộng hai số** như bình thường
2. **Kiểm tra tràn số** (overflow)
3. **Xử lý kết quả** theo yêu cầu

### Phương pháp 2: Xử lý tràn số
1. **Tràn số**: kết quả > 2^(n-1) - 1 hoặc < -(2^(n-1) - 1)
2. **Kết quả thực tế**: kết quả mod 2^n
3. **Carry flag**: bit tràn (nếu có)

## Bảng tràn số:
| Số bit | Phạm vi | Tràn khi |
|--------|---------|----------|
| 4      | -7 đến 7 | > 7 hoặc < -7 |
| 8      | -127 đến 127 | > 127 hoặc < -127 |
| 16     | -32767 đến 32767 | > 32767 hoặc < -32767 |
| 32     | -2147483647 đến 2147483647 | > 2147483647 hoặc < -2147483647 |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Cộng 5 + 3 trong 4 bit có dấu

**Lời giải:**
```
  0101₂ (5₁₀)
+ 0011₂ (3₁₀)
-------
  1000₂ (8₁₀)

Kiểm tra tràn:
5 + 3 = 8 > 7 (2^(4-1) - 1) ✗
Có tràn số

Kết quả thực tế: 8 mod 16 = 8
Kết quả: 5 + 3 = 8 (4 bit có dấu, có tràn)
```

### Bài 2: Cộng 3 + 2 trong 4 bit có dấu

**Lời giải:**
```
  0011₂ (3₁₀)
+ 0010₂ (2₁₀)
-------
  0101₂ (5₁₀)

Kiểm tra tràn:
3 + 2 = 5 ≤ 7 (2^(4-1) - 1) ✓
Không tràn số

Kết quả: 3 + 2 = 5 (4 bit có dấu)
```

### Bài 3: Cộng -5 + (-2) trong 4 bit có dấu

**Lời giải:**
```
  1101₂ (-5₁₀)
+ 1010₂ (-2₁₀)
-------
 10111₂ (-7₁₀)

Kiểm tra tràn:
-5 + (-2) = -7 ≥ -7 (2^(4-1) - 1) ✓
Không tràn số

Kết quả: -5 + (-2) = -7 (4 bit có dấu)
```

### Bài 4: Cộng -6 + (-3) trong 4 bit có dấu

**Lời giải:**
```
  1010₂ (-6₁₀)
+ 1101₂ (-3₁₀)
-------
 10111₂ (-9₁₀)

Kiểm tra tràn:
-6 + (-3) = -9 < -7 (2^(4-1) - 1) ✗
Có tràn số

Kết quả thực tế: -9 + 16 = 7
Kết quả: -6 + (-3) = 7 (4 bit có dấu, có tràn)
```

### Bài 5: Cộng 100 + 50 trong 8 bit có dấu

**Lời giải:**
```
  01100100₂ (100₁₀)
+ 00110010₂ (50₁₀)
-------
  10010110₂ (150₁₀)

Kiểm tra tràn:
100 + 50 = 150 > 127 (2^(8-1) - 1) ✗
Có tràn số

Kết quả thực tế: 150 mod 256 = 150
Kết quả: 100 + 50 = 150 (8 bit có dấu, có tràn)
```

### Bài 6: Cộng 50 + 30 trong 8 bit có dấu

**Lời giải:**
```
  00110010₂ (50₁₀)
+ 00011110₂ (30₁₀)
-------
  01010000₂ (80₁₀)

Kiểm tra tràn:
50 + 30 = 80 ≤ 127 (2^(8-1) - 1) ✓
Không tràn số

Kết quả: 50 + 30 = 80 (8 bit có dấu)
```

### Bài 7: Cộng -100 + (-50) trong 8 bit có dấu

**Lời giải:**
```
  10011100₂ (-100₁₀)
+ 11001110₂ (-50₁₀)
-------
 101101010₂ (-150₁₀)

Kiểm tra tràn:
-100 + (-50) = -150 < -127 (2^(8-1) - 1) ✗
Có tràn số

Kết quả thực tế: -150 + 256 = 106
Kết quả: -100 + (-50) = 106 (8 bit có dấu, có tràn)
```

### Bài 8: Cộng -50 + (-30) trong 8 bit có dấu

**Lời giải:**
```
  11001110₂ (-50₁₀)
+ 11100010₂ (-30₁₀)
-------
 110110000₂ (-80₁₀)

Kiểm tra tràn:
-50 + (-30) = -80 ≥ -127 (2^(8-1) - 1) ✓
Không tràn số

Kết quả: -50 + (-30) = -80 (8 bit có dấu)
```

### Bài 9: Cộng 1000 + 2000 trong 16 bit có dấu

**Lời giải:**
```
  0000001111101000₂ (1000₁₀)
+ 0000011111010000₂ (2000₁₀)
-------
  0000101110111000₂ (3000₁₀)

Kiểm tra tràn:
1000 + 2000 = 3000 ≤ 32767 (2^(16-1) - 1) ✓
Không tràn số

Kết quả: 1000 + 2000 = 3000 (16 bit có dấu)
```

### Bài 10: Cộng -1000 + (-2000) trong 16 bit có dấu

**Lời giải:**
```
  1111110000011000₂ (-1000₁₀)
+ 1111100000110000₂ (-2000₁₀)
-------
 1111010001001000₂ (-3000₁₀)

Kiểm tra tràn:
-1000 + (-2000) = -3000 ≥ -32767 (2^(16-1) - 1) ✓
Không tràn số

Kết quả: -1000 + (-2000) = -3000 (16 bit có dấu)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Cộng 2 + 3 trong 4 bit có dấu
2. Cộng 4 + 2 trong 4 bit có dấu
3. Cộng 6 + 1 trong 4 bit có dấu
4. Cộng 7 + 0 trong 4 bit có dấu
5. Cộng 0 + 0 trong 4 bit có dấu
6. Cộng 50 + 30 trong 8 bit có dấu
7. Cộng 100 + 20 trong 8 bit có dấu
8. Cộng 120 + 5 trong 8 bit có dấu
9. Cộng 127 + 0 trong 8 bit có dấu
10. Cộng 0 + 0 trong 8 bit có dấu

### Cấp độ trung bình (11-15):
11. Cộng 1000 + 2000 trong 16 bit có dấu
12. Cộng 5000 + 1000 trong 16 bit có dấu
13. Cộng 10000 + 5000 trong 16 bit có dấu
14. Cộng 20000 + 10000 trong 16 bit có dấu
15. Cộng 32767 + 0 trong 16 bit có dấu

### Cấp độ nâng cao (16-20):
16. Cộng 1000000 + 2000000 trong 32 bit có dấu
17. Cộng 5000000 + 1000000 trong 32 bit có dấu
18. Cộng 10000000 + 5000000 trong 32 bit có dấu
19. Cộng 20000000 + 10000000 trong 32 bit có dấu
20. Cộng 2147483647 + 0 trong 32 bit có dấu

---

## MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Cộng như bình thường** trước
- **Kiểm tra tràn số** sau
- **Xử lý kết quả** theo yêu cầu
- **Nhớ công thức** tràn: kết quả > 2^(n-1) - 1 hoặc < -(2^(n-1) - 1)

### LƯU Ý QUAN TRỌNG:
- **Tràn số** không phải lỗi, mà là đặc tính
- **Kết quả thực tế** = kết quả mod 2^n
- **Carry flag** = bit tràn (nếu có)
- **Kiểm tra** tràn trước khi sử dụng

### CÁCH KIỂM TRA:
- **Tính toán** kết quả trước
- **So sánh** với phạm vi bit
- **Xử lý** tràn nếu cần
- **Kiểm tra** bằng máy tính

### CÁC TRƯỜNG HỢP ĐẶC BIỆT:
- **A + 0 = A** (cộng với 0)
- **A + A = 2A** (cộng với chính nó)
- **2^(n-1) - 1 + 1 = -2^(n-1)** (tràn dương)

### PHƯƠNG PHÁP NHANH:
1. **Cộng** hai số
2. **Kiểm tra** tràn số
3. **Xử lý** kết quả
4. **Ghi** kết quả cuối cùng

### VÍ DỤ ỨNG DỤNG:
```cpp
// Phép cộng số nguyên có dấu
struct SignedAddResult {
    int result;
    bool overflow;
};

SignedAddResult signedAdd(int a, int b, int bits) {
    int maxValue = (1 << (bits - 1)) - 1;
    int minValue = -maxValue;  // Signed Magnitude: -(2^(n-1) - 1)
    int sum = a + b;
    bool overflow = sum > maxValue || sum < minValue;
    
    if (overflow) {
        sum = sum & ((1 << bits) - 1);
    }
    
    return {sum, overflow};
}

// Kiểm tra tràn số
bool checkOverflow(int a, int b, int bits) {
    int maxValue = (1 << (bits - 1)) - 1;
    int minValue = -maxValue;  // Signed Magnitude: -(2^(n-1) - 1)
    int sum = a + b;
    return sum > maxValue || sum < minValue;
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Signed arithmetic
- **Assembly**: ADD instruction với carry flag
- **Counters**: Loop counters, array indices
- **Memory addressing**: Address calculations
- **Hash functions**: Checksum calculations

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 4.1: Biểu diễn số nguyên có dấu
