# 3.1.1 BIỂU DIỄN SỐ NGUYÊN KHÔNG DẤU

## Mô tả dạng bài tập
Biểu diễn số nguyên không dấu trong hệ nhị phân với độ dài bit cố định và tính toán phạm vi giá trị.

## Phương pháp giải

### Phương pháp 1: Chuyển đổi trực tiếp
1. **Chuyển số thập phân** sang nhị phân
2. **Thêm số 0** vào đầu để đủ độ dài bit
3. **Kiểm tra** phạm vi giá trị

### Phương pháp 2: Tính toán phạm vi
1. **Phạm vi**: 0 đến 2^n - 1
2. **Số bit**: n bit
3. **Giá trị tối đa**: 2^n - 1
4. **Giá trị tối thiểu**: 0

## Bảng phạm vi giá trị:
| Số bit | Phạm vi | Giá trị tối đa |
|--------|---------|----------------|
| 4      | 0-15    | 15             |
| 8      | 0-255   | 255            |
| 16     | 0-65535 | 65535          |
| 32     | 0-4294967295 | 4294967295 |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Biểu diễn số 5 trong 4 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 5₁₀ sang nhị phân
5₁₀ = 101₂

Bước 2: Thêm số 0 vào đầu để đủ 4 bit
101₂ = 0101₂

Bước 3: Kiểm tra phạm vi
4 bit: 0 ≤ 5 ≤ 15 ✓

Kết quả: 5₁₀ = 0101₂ (4 bit không dấu)
```

### Bài 2: Biểu diễn số 12 trong 4 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 12₁₀ sang nhị phân
12₁₀ = 1100₂

Bước 2: Đã đủ 4 bit
1100₂ = 1100₂

Bước 3: Kiểm tra phạm vi
4 bit: 0 ≤ 12 ≤ 15 ✓

Kết quả: 12₁₀ = 1100₂ (4 bit không dấu)
```

### Bài 3: Biểu diễn số 25 trong 8 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 25₁₀ sang nhị phân
25₁₀ = 11001₂

Bước 2: Thêm số 0 vào đầu để đủ 8 bit
11001₂ = 00011001₂

Bước 3: Kiểm tra phạm vi
8 bit: 0 ≤ 25 ≤ 255 ✓

Kết quả: 25₁₀ = 00011001₂ (8 bit không dấu)
```

### Bài 4: Biểu diễn số 100 trong 8 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 100₁₀ sang nhị phân
100₁₀ = 1100100₂

Bước 2: Thêm số 0 vào đầu để đủ 8 bit
1100100₂ = 01100100₂

Bước 3: Kiểm tra phạm vi
8 bit: 0 ≤ 100 ≤ 255 ✓

Kết quả: 100₁₀ = 01100100₂ (8 bit không dấu)
```

### Bài 5: Biểu diễn số 255 trong 8 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 255₁₀ sang nhị phân
255₁₀ = 11111111₂

Bước 2: Đã đủ 8 bit
11111111₂ = 11111111₂

Bước 3: Kiểm tra phạm vi
8 bit: 0 ≤ 255 ≤ 255 ✓

Kết quả: 255₁₀ = 11111111₂ (8 bit không dấu)
```

### Bài 6: Biểu diễn số 1000 trong 16 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 1000₁₀ sang nhị phân
1000₁₀ = 1111101000₂

Bước 2: Thêm số 0 vào đầu để đủ 16 bit
1111101000₂ = 0000001111101000₂

Bước 3: Kiểm tra phạm vi
16 bit: 0 ≤ 1000 ≤ 65535 ✓

Kết quả: 1000₁₀ = 0000001111101000₂ (16 bit không dấu)
```

### Bài 7: Biểu diễn số 65535 trong 16 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 65535₁₀ sang nhị phân
65535₁₀ = 1111111111111111₂

Bước 2: Đã đủ 16 bit
1111111111111111₂ = 1111111111111111₂

Bước 3: Kiểm tra phạm vi
16 bit: 0 ≤ 65535 ≤ 65535 ✓

Kết quả: 65535₁₀ = 1111111111111111₂ (16 bit không dấu)
```

### Bài 8: Biểu diễn số 1000000 trong 32 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 1000000₁₀ sang nhị phân
1000000₁₀ = 11110100001001000000₂

Bước 2: Thêm số 0 vào đầu để đủ 32 bit
11110100001001000000₂ = 00000000000011110100001001000000₂

Bước 3: Kiểm tra phạm vi
32 bit: 0 ≤ 1000000 ≤ 4294967295 ✓

Kết quả: 1000000₁₀ = 00000000000011110100001001000000₂ (32 bit không dấu)
```

### Bài 9: Biểu diễn số 4294967295 trong 32 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 4294967295₁₀ sang nhị phân
4294967295₁₀ = 11111111111111111111111111111111₂

Bước 2: Đã đủ 32 bit
11111111111111111111111111111111₂ = 11111111111111111111111111111111₂

Bước 3: Kiểm tra phạm vi
32 bit: 0 ≤ 4294967295 ≤ 4294967295 ✓

Kết quả: 4294967295₁₀ = 11111111111111111111111111111111₂ (32 bit không dấu)
```

### Bài 10: Biểu diễn số 0 trong 8 bit không dấu

**Lời giải:**
```
Bước 1: Chuyển 0₁₀ sang nhị phân
0₁₀ = 0₂

Bước 2: Thêm số 0 vào đầu để đủ 8 bit
0₂ = 00000000₂

Bước 3: Kiểm tra phạm vi
8 bit: 0 ≤ 0 ≤ 255 ✓

Kết quả: 0₁₀ = 00000000₂ (8 bit không dấu)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Biểu diễn số 3 trong 4 bit không dấu
2. Biểu diễn số 7 trong 4 bit không dấu
3. Biểu diễn số 10 trong 4 bit không dấu
4. Biểu diễn số 15 trong 4 bit không dấu
5. Biểu diễn số 0 trong 4 bit không dấu
6. Biểu diễn số 50 trong 8 bit không dấu
7. Biểu diễn số 150 trong 8 bit không dấu
8. Biểu diễn số 200 trong 8 bit không dấu
9. Biểu diễn số 250 trong 8 bit không dấu
10. Biểu diễn số 0 trong 8 bit không dấu

### Cấp độ trung bình (11-15):
11. Biểu diễn số 1000 trong 16 bit không dấu
12. Biểu diễn số 10000 trong 16 bit không dấu
13. Biểu diễn số 50000 trong 16 bit không dấu
14. Biểu diễn số 60000 trong 16 bit không dấu
15. Biểu diễn số 0 trong 16 bit không dấu

### Cấp độ nâng cao (16-20):
16. Biểu diễn số 1000000 trong 32 bit không dấu
17. Biểu diễn số 10000000 trong 32 bit không dấu
18. Biểu diễn số 100000000 trong 32 bit không dấu
19. Biểu diễn số 1000000000 trong 32 bit không dấu
20. Biểu diễn số 0 trong 32 bit không dấu

---

## MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Chuyển sang nhị phân** trước
- **Thêm số 0** vào đầu để đủ bit
- **Kiểm tra phạm vi** trước khi biểu diễn
- **Nhớ công thức** phạm vi: 0 đến 2^n - 1

### LƯU Ý QUAN TRỌNG:
- **Không có bit dấu** (luôn dương)
- **Phạm vi**: 0 đến 2^n - 1
- **Số bit cố định** (không thay đổi)
- **Kiểm tra** tràn số trước khi biểu diễn

### CÁCH KIỂM TRA:
- **Chuyển ngược** từ nhị phân về thập phân
- **Kiểm tra phạm vi** với số bit
- **Sử dụng máy tính** để verify

### CÁC SỐ ĐẶC BIỆT:
- **0**: tất cả bit = 0
- **2^n - 1**: tất cả bit = 1
- **2^(n-1)**: bit đầu tiên = 1, còn lại = 0

### PHƯƠNG PHÁP NHANH:
1. **Chuyển sang nhị phân**
2. **Thêm số 0** vào đầu
3. **Kiểm tra phạm vi**
4. **Ghi kết quả**

### VÍ DỤ ỨNG DỤNG:
```cpp
// Biểu diễn số nguyên không dấu
string unsignedIntToBinary(int value, int bits) {
    if (value < 0 || value > (1 << bits) - 1) {
        return "Error: Value out of range";
    }
    
    string binary = "";
    for (int i = bits - 1; i >= 0; i--) {
        binary += ((value >> i) & 1) ? "1" : "0";
    }
    
    return binary;
}

// Chuyển từ nhị phân về số nguyên không dấu
int binaryToUnsignedInt(string binary) {
    int value = 0;
    for (char c : binary) {
        value = (value << 1) + (c - '0');
    }
    return value;
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Unsigned integer types
- **Assembly**: Unsigned arithmetic
- **Memory addressing**: Address calculations
- **Counters**: Loop counters, array indices
- **Flags**: Boolean flags, status bits

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 3.1: Biểu diễn số nguyên không dấu
