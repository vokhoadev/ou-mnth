# 3.1.4 PHÉP NHÂN SỐ NGUYÊN KHÔNG DẤU

## Mô tả dạng bài tập
Thực hiện phép nhân giữa hai số nguyên không dấu và xử lý tràn số (overflow).

## Phương pháp giải

### Phương pháp 1: Nhân trực tiếp
1. **Nhân hai số** như bình thường
2. **Kiểm tra tràn số** (overflow)
3. **Xử lý kết quả** theo yêu cầu

### Phương pháp 2: Xử lý tràn số
1. **Tràn số**: kết quả > 2^n - 1
2. **Kết quả thực tế**: kết quả mod 2^n
3. **Carry flag**: bit tràn (nếu có)

## Bảng tràn số:
| Số bit | Phạm vi | Tràn khi |
|--------|---------|----------|
| 4      | 0-15    | > 15     |
| 8      | 0-255   | > 255    |
| 16     | 0-65535 | > 65535  |
| 32     | 0-4294967295 | > 4294967295 |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Nhân 3 × 5 trong 4 bit không dấu

**Lời giải:**
```
    0011₂ (3₁₀)
  × 0101₂ (5₁₀)
  --------
    0011₂ (3 × 1)
   0000₂  (3 × 0, dịch trái 1 vị trí)
  0011₂   (3 × 1, dịch trái 2 vị trí)
  --------
  0001111₂ (15₁₀)

Kiểm tra tràn:
3 × 5 = 15 ≤ 15 (2⁴ - 1) ✓
Không tràn số

Kết quả: 3 × 5 = 15 (4 bit không dấu)
```

### Bài 2: Nhân 4 × 5 trong 4 bit không dấu

**Lời giải:**
```
    0100₂ (4₁₀)
  × 0101₂ (5₁₀)
  --------
    0100₂ (4 × 1)
   0000₂  (4 × 0, dịch trái 1 vị trí)
  0100₂   (4 × 1, dịch trái 2 vị trí)
  --------
  0010100₂ (20₁₀)

Kiểm tra tràn:
4 × 5 = 20 > 15 (2⁴ - 1) ✗
Có tràn số

Kết quả thực tế: 20 mod 16 = 4
Kết quả: 4 × 5 = 4 (4 bit không dấu, có tràn)
```

### Bài 3: Nhân 10 × 20 trong 8 bit không dấu

**Lời giải:**
```
    00001010₂ (10₁₀)
  × 00010100₂ (20₁₀)
  --------
    00000000₂ (10 × 0)
   00000000₂  (10 × 0, dịch trái 1 vị trí)
  00001010₂   (10 × 1, dịch trái 2 vị trí)
 00000000₂    (10 × 0, dịch trái 3 vị trí)
  --------
  0001100100₂ (200₁₀)

Kiểm tra tràn:
10 × 20 = 200 ≤ 255 (2⁸ - 1) ✓
Không tràn số

Kết quả: 10 × 20 = 200 (8 bit không dấu)
```

### Bài 4: Nhân 15 × 20 trong 8 bit không dấu

**Lời giải:**
```
    00001111₂ (15₁₀)
  × 00010100₂ (20₁₀)
  --------
    00000000₂ (15 × 0)
   00000000₂  (15 × 0, dịch trái 1 vị trí)
  00001111₂   (15 × 1, dịch trái 2 vị trí)
 00000000₂    (15 × 0, dịch trái 3 vị trí)
  --------
  000100101100₂ (300₁₀)

Kiểm tra tràn:
15 × 20 = 300 > 255 (2⁸ - 1) ✗
Có tràn số

Kết quả thực tế: 300 mod 256 = 44
Kết quả: 15 × 20 = 44 (8 bit không dấu, có tràn)
```

### Bài 5: Nhân 16 × 16 trong 8 bit không dấu

**Lời giải:**
```
    00010000₂ (16₁₀)
  × 00010000₂ (16₁₀)
  --------
    00000000₂ (16 × 0)
   00000000₂  (16 × 0, dịch trái 1 vị trí)
  00000000₂   (16 × 0, dịch trái 2 vị trí)
 00010000₂    (16 × 1, dịch trái 3 vị trí)
  --------
  000100000000₂ (256₁₀)

Kiểm tra tràn:
16 × 16 = 256 > 255 (2⁸ - 1) ✗
Có tràn số

Kết quả thực tế: 256 mod 256 = 0
Kết quả: 16 × 16 = 0 (8 bit không dấu, có tràn)
```

### Bài 6: Nhân 100 × 200 trong 16 bit không dấu

**Lời giải:**
```
    0000000001100100₂ (100₁₀)
  × 0000000011001000₂ (200₁₀)
  --------
    0000000000000000₂ (100 × 0)
   0000000000000000₂  (100 × 0, dịch trái 1 vị trí)
  0000000001100100₂   (100 × 1, dịch trái 2 vị trí)
 0000000000000000₂    (100 × 0, dịch trái 3 vị trí)
 0000000001100100₂    (100 × 1, dịch trái 4 vị trí)
 0000000000000000₂    (100 × 0, dịch trái 5 vị trí)
 0000000000000000₂    (100 × 0, dịch trái 6 vị trí)
 0000000000000000₂    (100 × 0, dịch trái 7 vị trí)
  --------
  000000000000110010000000₂ (20000₁₀)

Kiểm tra tràn:
100 × 200 = 20000 ≤ 65535 (2¹⁶ - 1) ✓
Không tràn số

Kết quả: 100 × 200 = 20000 (16 bit không dấu)
```

### Bài 7: Nhân 300 × 300 trong 16 bit không dấu

**Lời giải:**
```
    0000000100101100₂ (300₁₀)
  × 0000000100101100₂ (300₁₀)
  --------
    0000000000000000₂ (300 × 0)
   0000000000000000₂  (300 × 0, dịch trái 1 vị trí)
  0000000100101100₂   (300 × 1, dịch trái 2 vị trí)
 0000000000000000₂    (300 × 0, dịch trái 3 vị trí)
 0000000100101100₂    (300 × 1, dịch trái 4 vị trí)
 0000000000000000₂    (300 × 0, dịch trái 5 vị trí)
 0000000000000000₂    (300 × 0, dịch trái 6 vị trí)
 0000000000000000₂    (300 × 0, dịch trái 7 vị trí)
  --------
  000000000000100101100000000₂ (90000₁₀)

Kiểm tra tràn:
300 × 300 = 90000 > 65535 (2¹⁶ - 1) ✗
Có tràn số

Kết quả thực tế: 90000 mod 65536 = 24464
Kết quả: 300 × 300 = 24464 (16 bit không dấu, có tràn)
```

### Bài 8: Nhân 256 × 256 trong 16 bit không dấu

**Lời giải:**
```
    0000000100000000₂ (256₁₀)
  × 0000000100000000₂ (256₁₀)
  --------
    0000000000000000₂ (256 × 0)
   0000000000000000₂  (256 × 0, dịch trái 1 vị trí)
  0000000000000000₂   (256 × 0, dịch trái 2 vị trí)
 0000000000000000₂    (256 × 0, dịch trái 3 vị trí)
 0000000000000000₂    (256 × 0, dịch trái 4 vị trí)
 0000000000000000₂    (256 × 0, dịch trái 5 vị trí)
 0000000000000000₂    (256 × 0, dịch trái 6 vị trí)
 0000000100000000₂    (256 × 1, dịch trái 7 vị trí)
  --------
  000000010000000000000000₂ (65536₁₀)

Kiểm tra tràn:
256 × 256 = 65536 > 65535 (2¹⁶ - 1) ✗
Có tràn số

Kết quả thực tế: 65536 mod 65536 = 0
Kết quả: 256 × 256 = 0 (16 bit không dấu, có tràn)
```

### Bài 9: Nhân 1000 × 2000 trong 32 bit không dấu

**Lời giải:**
```
    00000000000000000000001111101000₂ (1000₁₀)
  × 00000000000000000000011111010000₂ (2000₁₀)
  --------
    00000000000000000000000000000000₂ (1000 × 0)
   00000000000000000000000000000000₂  (1000 × 0, dịch trái 1 vị trí)
  00000000000000000000001111101000₂   (1000 × 1, dịch trái 2 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 3 vị trí)
 00000000000000000000001111101000₂    (1000 × 1, dịch trái 4 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 5 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 6 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 7 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 8 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 9 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 10 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 11 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 12 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 13 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 14 vị trí)
 00000000000000000000000000000000₂    (1000 × 0, dịch trái 15 vị trí)
  --------
  0000000000000000000000000000000000000000000000000000000000000000₂ (2000000₁₀)

Kiểm tra tràn:
1000 × 2000 = 2000000 ≤ 4294967295 (2³² - 1) ✓
Không tràn số

Kết quả: 1000 × 2000 = 2000000 (32 bit không dấu)
```

### Bài 10: Nhân 65536 × 65536 trong 32 bit không dấu

**Lời giải:**
```
    00000000000000010000000000000000₂ (65536₁₀)
  × 00000000000000010000000000000000₂ (65536₁₀)
  --------
    00000000000000000000000000000000₂ (65536 × 0)
   00000000000000000000000000000000₂  (65536 × 0, dịch trái 1 vị trí)
  00000000000000000000000000000000₂   (65536 × 0, dịch trái 2 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 3 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 4 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 5 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 6 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 7 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 8 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 9 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 10 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 11 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 12 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 13 vị trí)
 00000000000000000000000000000000₂    (65536 × 0, dịch trái 14 vị trí)
 00000000000000010000000000000000₂    (65536 × 1, dịch trái 15 vị trí)
  --------
  00000000000000010000000000000000000000000000000000₂ (4294967296₁₀)

Kiểm tra tràn:
65536 × 65536 = 4294967296 > 4294967295 (2³² - 1) ✗
Có tràn số

Kết quả thực tế: 4294967296 mod 4294967296 = 0
Kết quả: 65536 × 65536 = 0 (32 bit không dấu, có tràn)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Nhân 2 × 3 trong 4 bit không dấu
2. Nhân 4 × 3 trong 4 bit không dấu
3. Nhân 5 × 2 trong 4 bit không dấu
4. Nhân 7 × 2 trong 4 bit không dấu
5. Nhân 8 × 2 trong 4 bit không dấu
6. Nhân 10 × 20 trong 8 bit không dấu
7. Nhân 15 × 15 trong 8 bit không dấu
8. Nhân 20 × 10 trong 8 bit không dấu
9. Nhân 25 × 10 trong 8 bit không dấu
10. Nhân 30 × 8 trong 8 bit không dấu

### Cấp độ trung bình (11-15):
11. Nhân 100 × 200 trong 16 bit không dấu
12. Nhân 150 × 150 trong 16 bit không dấu
13. Nhân 200 × 100 trong 16 bit không dấu
14. Nhân 250 × 100 trong 16 bit không dấu
15. Nhân 300 × 200 trong 16 bit không dấu

### Cấp độ nâng cao (16-20):
16. Nhân 1000 × 2000 trong 32 bit không dấu
17. Nhân 1500 × 1500 trong 32 bit không dấu
18. Nhân 2000 × 1000 trong 32 bit không dấu
19. Nhân 2500 × 1000 trong 32 bit không dấu
20. Nhân 3000 × 2000 trong 32 bit không dấu

---

## MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Nhân như bình thường** trước
- **Kiểm tra tràn số** sau
- **Xử lý kết quả** theo yêu cầu
- **Nhớ công thức** tràn: kết quả > 2^n - 1

### LƯU Ý QUAN TRỌNG:
- **Tràn số** không phải lỗi, mà là đặc tính
- **Kết quả thực tế** = kết quả mod 2^n
- **Carry flag** = bit tràn (nếu có)
- **Kiểm tra** tràn trước khi sử dụng

### CÁCH KIỂM TRA:
- **Tính toán** kết quả trước
- **So sánh** với phạm vi bit
- **Xử lý** tràn nếu cần
- **Kiểm tra** bằng máy tính

### CÁC TRƯỜNG HỢP ĐẶC BIỆT:
- **A × 0 = 0** (nhân với 0)
- **A × 1 = A** (nhân với 1)
- **A × 2 = A << 1** (nhân với 2)

### PHƯƠNG PHÁP NHANH:
1. **Nhân** hai số
2. **Kiểm tra** tràn số
3. **Xử lý** kết quả
4. **Ghi** kết quả cuối cùng

### VÍ DỤ ỨNG DỤNG:
```cpp
// Phép nhân số nguyên không dấu
struct UnsignedMulResult {
    int result;
    bool overflow;
};

UnsignedMulResult unsignedMul(int a, int b, int bits) {
    int maxValue = (1 << bits) - 1;
    long long product = (long long)a * b;
    bool overflow = product > maxValue;
    
    int result = (int)(product & maxValue);
    
    return {result, overflow};
}

// Kiểm tra tràn số
bool checkOverflow(int a, int b, int bits) {
    int maxValue = (1 << bits) - 1;
    return ((long long)a * b) > maxValue;
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Unsigned arithmetic
- **Assembly**: MUL instruction với carry flag
- **Counters**: Loop counters, array indices
- **Memory addressing**: Address calculations
- **Hash functions**: Checksum calculations

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 3.1: Biểu diễn số nguyên không dấu
