# 4.1.4 PHÉP NHÂN SỐ NGUYÊN CÓ DẤU

## Mô tả dạng bài tập
Thực hiện phép nhân giữa hai số nguyên có dấu và xử lý tràn số (overflow).

## Phương pháp giải

### Phương pháp 1: Nhân trực tiếp
1. **Nhân hai số** như bình thường
2. **Kiểm tra tràn số** (overflow)
3. **Xử lý kết quả** theo yêu cầu

### Phương pháp 2: Xử lý tràn số
1. **Tràn số**: kết quả > 2^(n-1) - 1 hoặc < -2^(n-1)
2. **Kết quả thực tế**: kết quả mod 2^n
3. **Carry flag**: bit tràn (nếu có)

## Bảng tràn số:
| Số bit | Phạm vi | Tràn khi |
|--------|---------|----------|
| 4      | -8 đến 7 | > 7 hoặc < -8 |
| 8      | -128 đến 127 | > 127 hoặc < -128 |
| 16     | -32768 đến 32767 | > 32767 hoặc < -32768 |
| 32     | -2147483648 đến 2147483647 | > 2147483647 hoặc < -2147483648 |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Nhân 3 × 2 trong 4 bit có dấu

**Lời giải:**
```
    0011₂ (3₁₀)
  × 0010₂ (2₁₀)
  --------
    0011₂ (3 × 1)
   0000₂  (3 × 0, dịch trái 1 vị trí)
  --------
  000110₂ (6₁₀)

Kiểm tra tràn:
3 × 2 = 6 ≤ 7 (2^(4-1) - 1) ✓
Không tràn số

Kết quả: 3 × 2 = 6 (4 bit có dấu)
```

### Bài 2: Nhân 4 × 2 trong 4 bit có dấu

**Lời giải:**
```
    0100₂ (4₁₀)
  × 0010₂ (2₁₀)
  --------
    0100₂ (4 × 1)
   0000₂  (4 × 0, dịch trái 1 vị trí)
  --------
  001000₂ (8₁₀)

Kiểm tra tràn:
4 × 2 = 8 > 7 (2^(4-1) - 1) ✗
Có tràn số

Kết quả thực tế: 8 mod 16 = 8
Kết quả: 4 × 2 = 8 (4 bit có dấu, có tràn)
```

### Bài 3: Nhân -3 × 2 trong 4 bit có dấu

**Lời giải:**
```
    1101₂ (-3₁₀)
  × 0010₂ (2₁₀)
  --------
    1101₂ (-3 × 1)
   0000₂  (-3 × 0, dịch trái 1 vị trí)
  --------
  011010₂ (-6₁₀)

Kiểm tra tràn:
-3 × 2 = -6 ≥ -8 (2^(4-1)) ✓
Không tràn số

Kết quả: -3 × 2 = -6 (4 bit có dấu)
```

### Bài 4: Nhân -4 × 2 trong 4 bit có dấu

**Lời giải:**
```
    1100₂ (-4₁₀)
  × 0010₂ (2₁₀)
  --------
    1100₂ (-4 × 1)
   0000₂  (-4 × 0, dịch trái 1 vị trí)
  --------
  011000₂ (-8₁₀)

Kiểm tra tràn:
-4 × 2 = -8 ≥ -8 (2^(4-1)) ✓
Không tràn số

Kết quả: -4 × 2 = -8 (4 bit có dấu)
```

### Bài 5: Nhân 10 × 20 trong 8 bit có dấu

**Lời giải:**
```
    00001010₂ (10₁₀)
  × 00010100₂ (20₁₀)
  --------
    00000000₂ (10 × 0)
   00000000₂  (10 × 0, dịch trái 1 vị trí)
  00001010₂   (10 × 1, dịch trái 2 vị trí)
 00000000₂    (10 × 0, dịch trái 3 vị trí)
  --------
  0001100100₂ (200₁₀)

Kiểm tra tràn:
10 × 20 = 200 > 127 (2^(8-1) - 1) ✗
Có tràn số

Kết quả thực tế: 200 mod 256 = 200
Kết quả: 10 × 20 = 200 (8 bit có dấu, có tràn)
```

### Bài 6: Nhân 5 × 10 trong 8 bit có dấu

**Lời giải:**
```
    00000101₂ (5₁₀)
  × 00001010₂ (10₁₀)
  --------
    00000000₂ (5 × 0)
   00000101₂  (5 × 1, dịch trái 1 vị trí)
  00000000₂   (5 × 0, dịch trái 2 vị trí)
 00000101₂    (5 × 1, dịch trái 3 vị trí)
  --------
  0000110010₂ (50₁₀)

Kiểm tra tràn:
5 × 10 = 50 ≤ 127 (2^(8-1) - 1) ✓
Không tràn số

Kết quả: 5 × 10 = 50 (8 bit có dấu)
```

### Bài 7: Nhân -10 × 20 trong 8 bit có dấu

**Lời giải:**
```
    11110110₂ (-10₁₀)
  × 00010100₂ (20₁₀)
  --------
    00000000₂ (-10 × 0)
   00000000₂  (-10 × 0, dịch trái 1 vị trí)
  11110110₂   (-10 × 1, dịch trái 2 vị trí)
 00000000₂    (-10 × 0, dịch trái 3 vị trí)
  --------
  1111011000₂ (-200₁₀)

Kiểm tra tràn:
-10 × 20 = -200 < -128 (2^(8-1)) ✗
Có tràn số

Kết quả thực tế: -200 + 256 = 56
Kết quả: -10 × 20 = 56 (8 bit có dấu, có tràn)
```

### Bài 8: Nhân -5 × 10 trong 8 bit có dấu

**Lời giải:**
```
    11111011₂ (-5₁₀)
  × 00001010₂ (10₁₀)
  --------
    00000000₂ (-5 × 0)
   11111011₂  (-5 × 1, dịch trái 1 vị trí)
  00000000₂   (-5 × 0, dịch trái 2 vị trí)
 11111011₂    (-5 × 1, dịch trái 3 vị trí)
  --------
  111100110₂ (-50₁₀)

Kiểm tra tràn:
-5 × 10 = -50 ≥ -128 (2^(8-1)) ✓
Không tràn số

Kết quả: -5 × 10 = -50 (8 bit có dấu)
```

### Bài 9: Nhân 100 × 200 trong 16 bit có dấu

**Lời giải:**
```
    0000000001100100₂ (100₁₀)
  × 0000000011001000₂ (200₁₀)
  --------
    0000000000000000₂ (100 × 0)
   0000000000000000₂  (100 × 0, dịch trái 1 vị trí)
  0000000001100100₂   (100 × 1, dịch trái 2 vị trí)
 0000000000000000₂    (100 × 0, dịch trái 3 vị trí)
 0000000001100100₂    (100 × 1, dịch trái 4 vị trí)
 0000000000000000₂    (100 × 0, dịch trái 5 vị trí)
 0000000000000000₂    (100 × 0, dịch trái 6 vị trí)
 0000000000000000₂    (100 × 0, dịch trái 7 vị trí)
  --------
  000000000000110010000000₂ (20000₁₀)

Kiểm tra tràn:
100 × 200 = 20000 ≤ 32767 (2^(16-1) - 1) ✓
Không tràn số

Kết quả: 100 × 200 = 20000 (16 bit có dấu)
```

### Bài 10: Nhân -100 × 200 trong 16 bit có dấu

**Lời giải:**
```
    1111111110011100₂ (-100₁₀)
  × 0000000011001000₂ (200₁₀)
  --------
    0000000000000000₂ (-100 × 0)
   0000000000000000₂  (-100 × 0, dịch trái 1 vị trí)
  1111111110011100₂   (-100 × 1, dịch trái 2 vị trí)
 0000000000000000₂    (-100 × 0, dịch trái 3 vị trí)
 1111111110011100₂    (-100 × 1, dịch trái 4 vị trí)
 0000000000000000₂    (-100 × 0, dịch trái 5 vị trí)
 0000000000000000₂    (-100 × 0, dịch trái 6 vị trí)
 0000000000000000₂    (-100 × 0, dịch trái 7 vị trí)
  --------
  111111111111001100000000₂ (-20000₁₀)

Kiểm tra tràn:
-100 × 200 = -20000 ≥ -32768 (2^(16-1)) ✓
Không tràn số

Kết quả: -100 × 200 = -20000 (16 bit có dấu)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Nhân 2 × 3 trong 4 bit có dấu
2. Nhân 3 × 2 trong 4 bit có dấu
3. Nhân 4 × 1 trong 4 bit có dấu
4. Nhân 5 × 1 trong 4 bit có dấu
5. Nhân 1 × 1 trong 4 bit có dấu
6. Nhân 10 × 5 trong 8 bit có dấu
7. Nhân 20 × 3 trong 8 bit có dấu
8. Nhân 30 × 2 trong 8 bit có dấu
9. Nhân 40 × 1 trong 8 bit có dấu
10. Nhân 1 × 1 trong 8 bit có dấu

### Cấp độ trung bình (11-15):
11. Nhân 100 × 50 trong 16 bit có dấu
12. Nhân 200 × 30 trong 16 bit có dấu
13. Nhân 300 × 20 trong 16 bit có dấu
14. Nhân 400 × 10 trong 16 bit có dấu
15. Nhân 500 × 5 trong 16 bit có dấu

### Cấp độ nâng cao (16-20):
16. Nhân 1000 × 500 trong 32 bit có dấu
17. Nhân 2000 × 300 trong 32 bit có dấu
18. Nhân 3000 × 200 trong 32 bit có dấu
19. Nhân 4000 × 100 trong 32 bit có dấu
20. Nhân 5000 × 50 trong 32 bit có dấu

---

## MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Nhân như bình thường** trước
- **Kiểm tra tràn số** sau
- **Xử lý kết quả** theo yêu cầu
- **Nhớ công thức** tràn: kết quả > 2^(n-1) - 1 hoặc < -2^(n-1)

### LƯU Ý QUAN TRỌNG:
- **Tràn số** không phải lỗi, mà là đặc tính
- **Kết quả thực tế** = kết quả mod 2^n
- **Carry flag** = bit tràn (nếu có)
- **Kiểm tra** tràn trước khi sử dụng

### CÁCH KIỂM TRA:
- **Tính toán** kết quả trước
- **So sánh** với phạm vi bit
- **Xử lý** tràn nếu cần
- **Kiểm tra** bằng máy tính

### CÁC TRƯỜNG HỢP ĐẶC BIỆT:
- **A × 0 = 0** (nhân với 0)
- **A × 1 = A** (nhân với 1)
- **A × 2 = A << 1** (nhân với 2)

### PHƯƠNG PHÁP NHANH:
1. **Nhân** hai số
2. **Kiểm tra** tràn số
3. **Xử lý** kết quả
4. **Ghi** kết quả cuối cùng

### VÍ DỤ ỨNG DỤNG:
```cpp
// Phép nhân số nguyên có dấu
struct SignedMulResult {
    int result;
    bool overflow;
};

SignedMulResult signedMul(int a, int b, int bits) {
    int maxValue = (1 << (bits - 1)) - 1;
    int minValue = -(1 << (bits - 1));
    long long product = (long long)a * b;
    bool overflow = product > maxValue || product < minValue;
    
    int result = (int)(product & ((1 << bits) - 1));
    
    return {result, overflow};
}

// Kiểm tra tràn số
bool checkOverflow(int a, int b, int bits) {
    int maxValue = (1 << (bits - 1)) - 1;
    int minValue = -(1 << (bits - 1));
    long long product = (long long)a * b;
    return product > maxValue || product < minValue;
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Signed arithmetic
- **Assembly**: MUL instruction với carry flag
- **Counters**: Loop counters, array indices
- **Memory addressing**: Address calculations
- **Hash functions**: Checksum calculations

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 4.1: Biểu diễn số nguyên có dấu
