# 4.2.6 PHÉP CỘNG SỐ NGUYÊN CÓ DẤU BẰNG MÃ QUÁ N

## Mô tả dạng bài tập
Thực hiện phép cộng giữa hai số nguyên có dấu biểu diễn bằng mã quá N và xử lý tràn số (overflow).

## Phương pháp giải

### Phương pháp 1: Cộng trực tiếp
1. **Cộng hai số** như bình thường
2. **Kiểm tra tràn số** (overflow)
3. **Xử lý kết quả** theo yêu cầu

### Phương pháp 2: Xử lý tràn số
1. **Tràn số**: kết quả > 2^(n-1) - 1 hoặc < -2^(n-1)
2. **Kết quả thực tế**: kết quả mod 2^n
3. **Carry flag**: bit tràn (nếu có)

## Bảng tràn số mã quá N:
| Số bit | Phạm vi | Tràn khi |
|--------|---------|----------|
| 4      | -8 đến 7 | > 7 hoặc < -8 |
| 8      | -128 đến 127 | > 127 hoặc < -128 |
| 16     | -32768 đến 32767 | > 32767 hoặc < -32768 |
| 32     | -2147483648 đến 2147483647 | > 2147483647 hoặc < -2147483648 |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Cộng 5 + 3 bằng mã quá 8 trong 4 bit

**Lời giải:**
```
  1101₂ (5₁₀ + 8 = 13₁₀)
+ 1011₂ (3₁₀ + 8 = 11₁₀)
-------
 11000₂ (24₁₀)

Kiểm tra tràn:
5 + 3 = 8 > 7 (2^(4-1) - 1) ✗
Có tràn số

Kết quả thực tế: 8 mod 16 = 8
Kết quả: 5 + 3 = 8 (4 bit mã quá 8, có tràn)
```

### Bài 2: Cộng 3 + 2 bằng mã quá 8 trong 4 bit

**Lời giải:**
```
  1011₂ (3₁₀ + 8 = 11₁₀)
+ 1010₂ (2₁₀ + 8 = 10₁₀)
-------
 10101₂ (21₁₀)

Kiểm tra tràn:
3 + 2 = 5 ≤ 7 (2^(4-1) - 1) ✓
Không tràn số

Kết quả: 3 + 2 = 5 (4 bit mã quá 8)
```

### Bài 3: Cộng -5 + (-3) bằng mã quá 8 trong 4 bit

**Lời giải:**
```
  0011₂ (-5₁₀ + 8 = 3₁₀)
+ 0101₂ (-3₁₀ + 8 = 5₁₀)
-------
  1000₂ (8₁₀)

Kiểm tra tràn:
-5 + (-3) = -8 ≥ -8 (2^(4-1)) ✓
Không tràn số

Kết quả: -5 + (-3) = -8 (4 bit mã quá 8)
```

### Bài 4: Cộng -6 + (-1) bằng mã quá 8 trong 4 bit

**Lời giải:**
```
  0010₂ (-6₁₀ + 8 = 2₁₀)
+ 0111₂ (-1₁₀ + 8 = 7₁₀)
-------
  1001₂ (9₁₀)

Kiểm tra tràn:
-6 + (-1) = -7 ≥ -8 (2^(4-1)) ✓
Không tràn số

Kết quả: -6 + (-1) = -7 (4 bit mã quá 8)
```

### Bài 5: Cộng 100 + 50 bằng mã quá 128 trong 8 bit

**Lời giải:**
```
  10011001₂ (100₁₀ + 128 = 228₁₀)
+ 10110010₂ (50₁₀ + 128 = 178₁₀)
-------
 101001011₂ (406₁₀)

Kiểm tra tràn:
100 + 50 = 150 > 127 (2^(8-1) - 1) ✗
Có tràn số

Kết quả thực tế: 150 mod 256 = 150
Kết quả: 100 + 50 = 150 (8 bit mã quá 128, có tràn)
```

### Bài 6: Cộng 50 + 30 bằng mã quá 128 trong 8 bit

**Lời giải:**
```
  10110010₂ (50₁₀ + 128 = 178₁₀)
+ 10011110₂ (30₁₀ + 128 = 158₁₀)
-------
 101010000₂ (336₁₀)

Kiểm tra tràn:
50 + 30 = 80 ≤ 127 (2^(8-1) - 1) ✓
Không tràn số

Kết quả: 50 + 30 = 80 (8 bit mã quá 128)
```

### Bài 7: Cộng -100 + (-50) bằng mã quá 128 trong 8 bit

**Lời giải:**
```
  00011011₂ (-100₁₀ + 128 = 28₁₀)
+ 01001101₂ (-50₁₀ + 128 = 78₁₀)
-------
  011010000₂ (106₁₀)

Kiểm tra tràn:
-100 + (-50) = -150 < -128 (2^(8-1)) ✗
Có tràn số

Kết quả thực tế: -150 + 256 = 106
Kết quả: -100 + (-50) = 106 (8 bit mã quá 128, có tràn)
```

### Bài 8: Cộng -50 + (-30) bằng mã quá 128 trong 8 bit

**Lời giải:**
```
  01001101₂ (-50₁₀ + 128 = 78₁₀)
+ 01100001₂ (-30₁₀ + 128 = 98₁₀)
-------
  101011110₂ (176₁₀)

Kiểm tra tràn:
-50 + (-30) = -80 ≥ -128 (2^(8-1)) ✓
Không tràn số

Kết quả: -50 + (-30) = -80 (8 bit mã quá 128)
```

### Bài 9: Cộng 1000 + 2000 bằng mã quá 32768 trong 16 bit

**Lời giải:**
```
  1000001111101000₂ (1000₁₀ + 32768 = 33768₁₀)
+ 1000011111010000₂ (2000₁₀ + 32768 = 34768₁₀)
-------
 1000010111011000₂ (68536₁₀)

Kiểm tra tràn:
1000 + 2000 = 3000 ≤ 32767 (2^(16-1) - 1) ✓
Không tràn số

Kết quả: 1000 + 2000 = 3000 (16 bit mã quá 32768)
```

### Bài 10: Cộng -1000 + (-2000) bằng mã quá 32768 trong 16 bit

**Lời giải:**
```
  0111110000011000₂ (-1000₁₀ + 32768 = 31768₁₀)
+ 0111100000110000₂ (-2000₁₀ + 32768 = 30768₁₀)
-------
 1111010001001000₂ (62536₁₀)

Kiểm tra tràn:
-1000 + (-2000) = -3000 ≥ -32768 (2^(16-1)) ✓
Không tràn số

Kết quả: -1000 + (-2000) = -3000 (16 bit mã quá 32768)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Cộng 2 + 3 bằng mã quá 8 trong 4 bit
2. Cộng 4 + 2 bằng mã quá 8 trong 4 bit
3. Cộng 6 + 1 bằng mã quá 8 trong 4 bit
4. Cộng 7 + 0 bằng mã quá 8 trong 4 bit
5. Cộng 0 + 0 bằng mã quá 8 trong 4 bit
6. Cộng 50 + 30 bằng mã quá 128 trong 8 bit
7. Cộng 100 + 20 bằng mã quá 128 trong 8 bit
8. Cộng 120 + 5 bằng mã quá 128 trong 8 bit
9. Cộng 127 + 0 bằng mã quá 128 trong 8 bit
10. Cộng 0 + 0 bằng mã quá 128 trong 8 bit

### Cấp độ trung bình (11-15):
11. Cộng 1000 + 2000 bằng mã quá 32768 trong 16 bit
12. Cộng 5000 + 1000 bằng mã quá 32768 trong 16 bit
13. Cộng 10000 + 5000 bằng mã quá 32768 trong 16 bit
14. Cộng 20000 + 10000 bằng mã quá 32768 trong 16 bit
15. Cộng 32767 + 0 bằng mã quá 32768 trong 16 bit

### Cấp độ nâng cao (16-20):
16. Cộng 1000000 + 2000000 bằng mã quá 2147483648 trong 32 bit
17. Cộng 5000000 + 1000000 bằng mã quá 2147483648 trong 32 bit
18. Cộng 10000000 + 5000000 bằng mã quá 2147483648 trong 32 bit
19. Cộng 20000000 + 10000000 bằng mã quá 2147483648 trong 32 bit
20. Cộng 2147483647 + 0 bằng mã quá 2147483648 trong 32 bit

---

##  MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Cộng như bình thường** trước
- **Kiểm tra tràn số** sau
- **Xử lý kết quả** theo yêu cầu
- **Nhớ công thức** tràn: kết quả > 2^(n-1) - 1 hoặc < -2^(n-1)

### LƯU Ý QUAN TRỌNG:
- **Tràn số** không phải lỗi, mà là đặc tính
- **Kết quả thực tế** = kết quả mod 2^n
- **Carry flag** = bit tràn (nếu có)
- **Kiểm tra** tràn trước khi sử dụng

### CÁCH KIỂM TRA:
- **Tính toán** kết quả trước
- **So sánh** với phạm vi bit
- **Xử lý** tràn nếu cần
- **Kiểm tra** bằng máy tính

### CÁC TRƯỜNG HỢP ĐẶC BIỆT:
- **A + 0 = A** (cộng với 0)
- **A + A = 2A** (cộng với chính nó)
- **2^(n-1) - 1 + 1 = -2^(n-1)** (tràn dương)

### PHƯƠNG PHÁP NHANH:
1. **Cộng** hai số
2. **Kiểm tra** tràn số
3. **Xử lý** kết quả
4. **Ghi** kết quả cuối cùng

### VÍ DỤ ỨNG DỤNG:
```cpp
// Phép cộng số nguyên có dấu bằng mã quá N
struct ExcessNAddResult {
    int result;
    bool overflow;
};

ExcessNAddResult excessNAdd(int a, int b, int bits) {
    int N = 1 << (bits - 1);
    int maxValue = N - 1;
    int minValue = -N;
    int sum = a + b;
    bool overflow = sum > maxValue || sum < minValue;
    
    if (overflow) {
        sum = sum & ((1 << bits) - 1);
    }
    
    return {sum, overflow};
}

// Kiểm tra tràn số
bool checkOverflow(int a, int b, int bits) {
    int N = 1 << (bits - 1);
    int maxValue = N - 1;
    int minValue = -N;
    int sum = a + b;
    return sum > maxValue || sum < minValue;
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Excess-N arithmetic
- **Assembly**: Excess-N operations
- **Counters**: Loop counters, array indices
- **Memory addressing**: Address calculations
- **Hash functions**: Checksum calculations

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 4.2: Biểu diễn số nguyên có dấu bằng mã quá N








