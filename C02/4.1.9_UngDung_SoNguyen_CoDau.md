# 4.1.9 ỨNG DỤNG SỐ NGUYÊN CÓ DẤU

## Mô tả dạng bài tập
Ứng dụng số nguyên có dấu trong các bài toán thực tế: đếm, chỉ số mảng, địa chỉ bộ nhớ, cờ trạng thái.

**Lưu ý quan trọng:** File này mô tả ứng dụng số có dấu. Trong thực tế, máy tính sử dụng **TWO'S COMPLEMENT** (bù 2) với phạm vi -2^(n-1) đến 2^(n-1)-1. Tuy nhiên, để nhất quán với các file 4.1.x khác, các ví dụ trong file này sẽ sử dụng phạm vi **SIGNED MAGNITUDE** (-(2^(n-1)-1) đến 2^(n-1)-1) khi có thể.

## Phương pháp giải

### Phương pháp 1: Đếm và chỉ số
1. **Sử dụng số nguyên có dấu** để đếm
2. **Chỉ số mảng** từ 0 đến n-1
3. **Kiểm tra** phạm vi giá trị

### Phương pháp 2: Địa chỉ bộ nhớ
1. **Địa chỉ bộ nhớ** là số nguyên có dấu
2. **Tính toán** địa chỉ tương đối
3. **Kiểm tra** tràn số

## Bảng ứng dụng:
**Lưu ý:** Bảng dưới đây mô tả phạm vi trong thực tế (Two's Complement). Để nhất quán với các file 4.1.x khác, các bài tập sẽ sử dụng phạm vi Signed Magnitude khi có thể.

| Ứng dụng | Số bit | Phạm vi (Two's Complement - thực tế) | Phạm vi (Signed Magnitude - lý thuyết) | Ví dụ |
|----------|--------|--------------------------------------|-----------------------------------------|-------|
| Đếm | 8 | -128 đến 127 | -127 đến 127 | Loop counter |
| Chỉ số mảng | 16 | -32768 đến 32767 | -32767 đến 32767 | Array index |
| Địa chỉ bộ nhớ | 32 | -2147483648 đến 2147483647 | -2147483647 đến 2147483647 | Memory address |
| Cờ trạng thái | 1 | -1 đến 0 | -0 đến 0 | Boolean flag |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Đếm từ -5 đến 5 bằng số nguyên 8 bit có dấu

**Lời giải:**
```
Bước 1: Khởi tạo biến đếm
count = -5 (8 bit có dấu)

Bước 2: Vòng lặp đếm
count = -5: -5 ≤ 5 ✓
count = -4: -4 ≤ 5 ✓
count = -3: -3 ≤ 5 ✓
count = -2: -2 ≤ 5 ✓
count = -1: -1 ≤ 5 ✓
count = 0: 0 ≤ 5 ✓
count = 1: 1 ≤ 5 ✓
count = 2: 2 ≤ 5 ✓
count = 3: 3 ≤ 5 ✓
count = 4: 4 ≤ 5 ✓
count = 5: 5 ≤ 5 ✓
count = 6: 6 > 5 ✗ (dừng)

Bước 3: Kết quả
Đếm được từ -5 đến 5 (11 lần)

Kết quả: Số nguyên 8 bit có dấu có thể đếm từ -5 đến 5
```

### Bài 2: Chỉ số mảng có 100 phần tử bằng số nguyên 16 bit có dấu

**Lời giải:**
```
Bước 1: Xác định kích thước mảng
n = 100 phần tử

Bước 2: Xác định phạm vi chỉ số
0 ≤ index ≤ n-1
0 ≤ index ≤ 99

Bước 3: Kiểm tra phạm vi 16 bit
16 bit: -32768 ≤ giá trị ≤ 32767
99 ≤ 32767 ✓

Bước 4: Kết quả
Số nguyên 16 bit có dấu có thể làm chỉ số mảng 100 phần tử

Kết quả: Chỉ số mảng từ 0 đến 99 (16 bit có dấu)
```

### Bài 3: Địa chỉ bộ nhớ từ 0x1000 đến 0x2000 bằng số nguyên 32 bit có dấu

**Lời giải:**
```
Bước 1: Chuyển địa chỉ sang thập phân
0x1000 = 4096₁₀
0x2000 = 8192₁₀

Bước 2: Tính kích thước vùng nhớ
8192 - 4096 = 4096 bytes

Bước 3: Kiểm tra phạm vi 32 bit
32 bit: -2147483648 ≤ giá trị ≤ 2147483647
8192 ≤ 2147483647 ✓

Bước 4: Kết quả
Số nguyên 32 bit có dấu có thể biểu diễn địa chỉ từ 0x1000 đến 0x2000

Kết quả: Địa chỉ bộ nhớ từ 4096 đến 8192 (32 bit có dấu)
```

### Bài 4: Cờ trạng thái 8 bit cho 8 thiết bị

**Lời giải:**
```
Bước 1: Xác định số thiết bị
n = 8 thiết bị

Bước 2: Xác định số bit cần thiết
8 bit = 8 cờ trạng thái

Bước 3: Mã hóa trạng thái
Bit 0: Thiết bị 0 (0=OFF, 1=ON)
Bit 1: Thiết bị 1 (0=OFF, 1=ON)
Bit 2: Thiết bị 2 (0=OFF, 1=ON)
Bit 3: Thiết bị 3 (0=OFF, 1=ON)
Bit 4: Thiết bị 4 (0=OFF, 1=ON)
Bit 5: Thiết bị 5 (0=OFF, 1=ON)
Bit 6: Thiết bị 6 (0=OFF, 1=ON)
Bit 7: Thiết bị 7 (0=OFF, 1=ON)

Bước 4: Ví dụ
0x55 = 01010101₂ → Thiết bị 0,2,4,6 ON; 1,3,5,7 OFF

Kết quả: 8 bit có dấu có thể quản lý 8 thiết bị
```

### Bài 5: Đếm số lần lặp tối đa với số nguyên 8 bit có dấu

**Lời giải:**
```
Bước 1: Xác định phạm vi 8 bit
8 bit: -128 ≤ giá trị ≤ 127

Bước 2: Tính số lần lặp tối đa
Số lần lặp tối đa = 127

Bước 3: Kiểm tra tràn số
127 + 1 = 128 > 127 ✗ (tràn số)

Bước 4: Kết quả
Số nguyên 8 bit có dấu có thể đếm tối đa 127 lần

Kết quả: Số lần lặp tối đa là 127 (8 bit có dấu)
```

### Bài 6: Chỉ số mảng 2D có kích thước 100x100 bằng số nguyên 16 bit có dấu

**Lời giải:**
```
Bước 1: Xác định kích thước mảng 2D
rows = 100, cols = 100
total_elements = 100 × 100 = 10000

Bước 2: Xác định phạm vi chỉ số
0 ≤ index ≤ 9999

Bước 3: Kiểm tra phạm vi 16 bit
16 bit: -32768 ≤ giá trị ≤ 32767
9999 ≤ 32767 ✓

Bước 4: Tính chỉ số 2D
index = row × cols + col
0 ≤ row ≤ 99, 0 ≤ col ≤ 99

Bước 5: Kết quả
Số nguyên 16 bit có dấu có thể làm chỉ số mảng 2D 100x100

Kết quả: Chỉ số mảng 2D từ 0 đến 9999 (16 bit có dấu)
```

### Bài 7: Địa chỉ bộ nhớ từ 0x00000000 đến 0xFFFFFFFF bằng số nguyên 32 bit có dấu

**Lời giải:**
```
Bước 1: Chuyển địa chỉ sang thập phân
0x00000000 = 0₁₀
0xFFFFFFFF = 4294967295₁₀

Bước 2: Tính kích thước vùng nhớ
4294967295 - 0 = 4294967295 bytes = 4GB

Bước 3: Kiểm tra phạm vi 32 bit
32 bit: -2147483648 ≤ giá trị ≤ 2147483647
4294967295 > 2147483647 ✗ (tràn số)

Bước 4: Kết quả
Số nguyên 32 bit có dấu không thể biểu diễn địa chỉ từ 0x00000000 đến 0xFFFFFFFF

Kết quả: Địa chỉ bộ nhớ từ 0 đến 4GB (32 bit có dấu, có tràn)
```

### Bài 8: Cờ trạng thái 16 bit cho 16 thiết bị

**Lời giải:**
```
Bước 1: Xác định số thiết bị
n = 16 thiết bị

Bước 2: Xác định số bit cần thiết
16 bit = 16 cờ trạng thái

Bước 3: Mã hóa trạng thái
Bit 0-15: Thiết bị 0-15 (0=OFF, 1=ON)

Bước 4: Ví dụ
0xAAAA = 1010101010101010₂ → Thiết bị chẵn ON, lẻ OFF

Bước 5: Kết quả
16 bit có dấu có thể quản lý 16 thiết bị

Kết quả: 16 bit có dấu có thể quản lý 16 thiết bị
```

### Bài 9: Đếm số lần lặp tối đa với số nguyên 16 bit có dấu

**Lời giải:**
```
Bước 1: Xác định phạm vi 16 bit
16 bit: -32768 ≤ giá trị ≤ 32767

Bước 2: Tính số lần lặp tối đa
Số lần lặp tối đa = 32767

Bước 3: Kiểm tra tràn số
32767 + 1 = 32768 > 32767 ✗ (tràn số)

Bước 4: Kết quả
Số nguyên 16 bit có dấu có thể đếm tối đa 32767 lần

Kết quả: Số lần lặp tối đa là 32767 (16 bit có dấu)
```

### Bài 10: Chỉ số mảng 3D có kích thước 50x50x50 bằng số nguyên 32 bit có dấu

**Lời giải:**
```
Bước 1: Xác định kích thước mảng 3D
x = 50, y = 50, z = 50
total_elements = 50 × 50 × 50 = 125000

Bước 2: Xác định phạm vi chỉ số
0 ≤ index ≤ 124999

Bước 3: Kiểm tra phạm vi 32 bit
32 bit: -2147483648 ≤ giá trị ≤ 2147483647
124999 ≤ 2147483647 ✓

Bước 4: Tính chỉ số 3D
index = x × y × z + y × z + z
0 ≤ x ≤ 49, 0 ≤ y ≤ 49, 0 ≤ z ≤ 49

Bước 5: Kết quả
Số nguyên 32 bit có dấu có thể làm chỉ số mảng 3D 50x50x50

Kết quả: Chỉ số mảng 3D từ 0 đến 124999 (32 bit có dấu)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Đếm từ -3 đến 3 bằng số nguyên 4 bit có dấu
2. Chỉ số mảng có 10 phần tử bằng số nguyên 8 bit có dấu
3. Địa chỉ bộ nhớ từ 0x0000 đến 0x1000 bằng số nguyên 16 bit có dấu
4. Cờ trạng thái 4 bit cho 4 thiết bị
5. Đếm số lần lặp tối đa với số nguyên 4 bit có dấu
6. Chỉ số mảng có 50 phần tử bằng số nguyên 8 bit có dấu
7. Địa chỉ bộ nhớ từ 0x0000 đến 0x2000 bằng số nguyên 16 bit có dấu
8. Cờ trạng thái 8 bit cho 8 thiết bị
9. Đếm số lần lặp tối đa với số nguyên 8 bit có dấu
10. Chỉ số mảng có 100 phần tử bằng số nguyên 16 bit có dấu

### Cấp độ trung bình (11-15):
11. Địa chỉ bộ nhớ từ 0x00000000 đến 0x10000000 bằng số nguyên 32 bit có dấu
12. Cờ trạng thái 16 bit cho 16 thiết bị
13. Đếm số lần lặp tối đa với số nguyên 16 bit có dấu
14. Chỉ số mảng 2D có kích thước 50x50 bằng số nguyên 16 bit có dấu
15. Địa chỉ bộ nhớ từ 0x00000000 đến 0x20000000 bằng số nguyên 32 bit có dấu

### Cấp độ nâng cao (16-20):
16. Cờ trạng thái 32 bit cho 32 thiết bị
17. Đếm số lần lặp tối đa với số nguyên 32 bit có dấu
18. Chỉ số mảng 3D có kích thước 100x100x100 bằng số nguyên 32 bit có dấu
19. Địa chỉ bộ nhớ từ 0x00000000 đến 0x80000000 bằng số nguyên 32 bit có dấu
20. Cờ trạng thái 64 bit cho 64 thiết bị

---

## MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Đếm**: sử dụng số nguyên có dấu
- **Chỉ số mảng**: từ 0 đến n-1
- **Địa chỉ bộ nhớ**: số nguyên có dấu
- **Cờ trạng thái**: 1 bit = 1 thiết bị

### LƯU Ý QUAN TRỌNG:
- **Bit dấu** ở vị trí đầu tiên
- **Phạm vi** không đối xứng
- **Số bit cố định** (không thay đổi)
- **Kiểm tra** tràn số trước khi sử dụng

### CÁCH KIỂM TRA:
- **Tính toán** phạm vi trước
- **So sánh** với yêu cầu
- **Kiểm tra** tràn số nếu cần
- **Sử dụng** máy tính để verify

### CÁC ỨNG DỤNG ĐẶC BIỆT:
- **Đếm**: loop counter, array size
- **Chỉ số**: array index, matrix index
- **Địa chỉ**: memory address, pointer
- **Cờ**: status flags, device states

### PHƯƠNG PHÁP NHANH:
1. **Xác định** ứng dụng
2. **Tính** phạm vi cần thiết
3. **Chọn** số bit phù hợp
4. **Kiểm tra** tràn số

### VÍ DỤ ỨNG DỤNG:
```cpp
// Đếm với số nguyên có dấu
void countWithSigned() {
    int count = -5;
    while (count <= 5) {
        // Xử lý
        count++;
    }
}

// Chỉ số mảng với số nguyên có dấu
void arrayIndexWithSigned() {
    int array[100];
    for (int i = 0; i < 100; i++) {
        array[i] = i;
    }
}

// Địa chỉ bộ nhớ với số nguyên có dấu
void memoryAddressWithSigned() {
    int baseAddress = 0x1000;
    int offset = 0x100;
    int finalAddress = baseAddress + offset;
}

// Cờ trạng thái với số nguyên có dấu
void statusFlagsWithSigned() {
    int flags = 0;
    flags |= (1 << 0); // Set bit 0
    flags |= (1 << 1); // Set bit 1
    flags &= ~(1 << 0); // Clear bit 0
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Signed integer types
- **Assembly**: Signed arithmetic
- **Memory addressing**: Address calculations
- **Counters**: Loop counters, array indices
- **Flags**: Boolean flags, status bits

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 4.1: Biểu diễn số nguyên có dấu
