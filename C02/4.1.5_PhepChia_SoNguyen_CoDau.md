# 4.1.5 PHÉP CHIA SỐ NGUYÊN CÓ DẤU

## Mô tả dạng bài tập
Thực hiện phép chia giữa hai số nguyên có dấu và xử lý tràn số (overflow).

## Phương pháp giải

### Phương pháp 1: Chia trực tiếp
1. **Chia hai số** như bình thường
2. **Kiểm tra tràn số** (overflow)
3. **Xử lý kết quả** theo yêu cầu

### Phương pháp 2: Xử lý tràn số
1. **Tràn số**: kết quả > 2^(n-1) - 1 hoặc < -2^(n-1)
2. **Kết quả thực tế**: kết quả mod 2^n
3. **Carry flag**: bit tràn (nếu có)

## Bảng tràn số:
| Số bit | Phạm vi | Tràn khi |
|--------|---------|----------|
| 4      | -8 đến 7 | > 7 hoặc < -8 |
| 8      | -128 đến 127 | > 127 hoặc < -128 |
| 16     | -32768 đến 32767 | > 32767 hoặc < -32768 |
| 32     | -2147483648 đến 2147483647 | > 2147483647 hoặc < -2147483648 |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Chia 6 ÷ 2 trong 4 bit có dấu

**Lời giải:**
```
     3₄
  --------
2₄)6₄
   -6₄
   ------
      0₄

Chi tiết:
Bước 1: Lấy 6₄, so sánh với 2₄
6₄ ≥ 2₄ → thương = 3, dư = 6₄ - 6₄ = 0₄

Kiểm tra tràn:
6 ÷ 2 = 3 ≤ 7 (2^(4-1) - 1) ✓
Không tràn số

Kết quả: 6 ÷ 2 = 3 (4 bit có dấu)
```

### Bài 2: Chia 8 ÷ 2 trong 4 bit có dấu

**Lời giải:**
```
     4₄
  --------
2₄)8₄
   -8₄
   ------
      0₄

Chi tiết:
Bước 1: Lấy 8₄, so sánh với 2₄
8₄ ≥ 2₄ → thương = 4, dư = 8₄ - 8₄ = 0₄

Kiểm tra tràn:
8 ÷ 2 = 4 ≤ 7 (2^(4-1) - 1) ✓
Không tràn số

Kết quả: 8 ÷ 2 = 4 (4 bit có dấu)
```

### Bài 3: Chia -6 ÷ 2 trong 4 bit có dấu

**Lời giải:**
```
    -3₄
  --------
2₄)-6₄
   -6₄
   ------
      0₄

Chi tiết:
Bước 1: Lấy -6₄, so sánh với 2₄
-6₄ < 2₄ → thương = -3, dư = -6₄ - (-6₄) = 0₄

Kiểm tra tràn:
-6 ÷ 2 = -3 ≥ -8 (2^(4-1)) ✓
Không tràn số

Kết quả: -6 ÷ 2 = -3 (4 bit có dấu)
```

### Bài 4: Chia -8 ÷ 2 trong 4 bit có dấu

**Lời giải:**
```
    -4₄
  --------
2₄)-8₄
   -8₄
   ------
      0₄

Chi tiết:
Bước 1: Lấy -8₄, so sánh với 2₄
-8₄ < 2₄ → thương = -4, dư = -8₄ - (-8₄) = 0₄

Kiểm tra tràn:
-8 ÷ 2 = -4 ≥ -8 (2^(4-1)) ✓
Không tràn số

Kết quả: -8 ÷ 2 = -4 (4 bit có dấu)
```

### Bài 5: Chia 100 ÷ 20 trong 8 bit có dấu

**Lời giải:**
```
     5₈
  --------
20₈)100₈
   -100₈
   ------
      0₈

Chi tiết:
Bước 1: Lấy 100₈, so sánh với 20₈
100₈ ≥ 20₈ → thương = 5, dư = 100₈ - 100₈ = 0₈

Kiểm tra tràn:
100 ÷ 20 = 5 ≤ 127 (2^(8-1) - 1) ✓
Không tràn số

Kết quả: 100 ÷ 20 = 5 (8 bit có dấu)
```

### Bài 6: Chia 200 ÷ 20 trong 8 bit có dấu

**Lời giải:**
```
    10₈
  --------
20₈)200₈
   -200₈
   ------
      0₈

Chi tiết:
Bước 1: Lấy 200₈, so sánh với 20₈
200₈ ≥ 20₈ → thương = 10, dư = 200₈ - 200₈ = 0₈

Kiểm tra tràn:
200 ÷ 20 = 10 ≤ 127 (2^(8-1) - 1) ✓
Không tràn số

Kết quả: 200 ÷ 20 = 10 (8 bit có dấu)
```

### Bài 7: Chia -100 ÷ 20 trong 8 bit có dấu

**Lời giải:**
```
    -5₈
  --------
20₈)-100₈
   -100₈
   ------
      0₈

Chi tiết:
Bước 1: Lấy -100₈, so sánh với 20₈
-100₈ < 20₈ → thương = -5, dư = -100₈ - (-100₈) = 0₈

Kiểm tra tràn:
-100 ÷ 20 = -5 ≥ -128 (2^(8-1)) ✓
Không tràn số

Kết quả: -100 ÷ 20 = -5 (8 bit có dấu)
```

### Bài 8: Chia -200 ÷ 20 trong 8 bit có dấu

**Lời giải:**
```
   -10₈
  --------
20₈)-200₈
   -200₈
   ------
      0₈

Chi tiết:
Bước 1: Lấy -200₈, so sánh với 20₈
-200₈ < 20₈ → thương = -10, dư = -200₈ - (-200₈) = 0₈

Kiểm tra tràn:
-200 ÷ 20 = -10 ≥ -128 (2^(8-1)) ✓
Không tràn số

Kết quả: -200 ÷ 20 = -10 (8 bit có dấu)
```

### Bài 9: Chia 1000 ÷ 100 trong 16 bit có dấu

**Lời giải:**
```
    10₁₆
  --------
100₁₆)1000₁₆
   -1000₁₆
   ------
       0₁₆

Chi tiết:
Bước 1: Lấy 1000₁₆, so sánh với 100₁₆
1000₁₆ ≥ 100₁₆ → thương = 10, dư = 1000₁₆ - 1000₁₆ = 0₁₆

Kiểm tra tràn:
1000 ÷ 100 = 10 ≤ 32767 (2^(16-1) - 1) ✓
Không tràn số

Kết quả: 1000 ÷ 100 = 10 (16 bit có dấu)
```

### Bài 10: Chia -1000 ÷ 100 trong 16 bit có dấu

**Lời giải:**
```
   -10₁₆
  --------
100₁₆)-1000₁₆
   -1000₁₆
   ------
       0₁₆

Chi tiết:
Bước 1: Lấy -1000₁₆, so sánh với 100₁₆
-1000₁₆ < 100₁₆ → thương = -10, dư = -1000₁₆ - (-1000₁₆) = 0₁₆

Kiểm tra tràn:
-1000 ÷ 100 = -10 ≥ -32768 (2^(16-1)) ✓
Không tràn số

Kết quả: -1000 ÷ 100 = -10 (16 bit có dấu)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Chia 4 ÷ 2 trong 4 bit có dấu
2. Chia 6 ÷ 3 trong 4 bit có dấu
3. Chia 8 ÷ 4 trong 4 bit có dấu
4. Chia 10 ÷ 5 trong 4 bit có dấu
5. Chia 0 ÷ 1 trong 4 bit có dấu
6. Chia 50 ÷ 10 trong 8 bit có dấu
7. Chia 100 ÷ 20 trong 8 bit có dấu
8. Chia 150 ÷ 30 trong 8 bit có dấu
9. Chia 200 ÷ 40 trong 8 bit có dấu
10. Chia 0 ÷ 1 trong 8 bit có dấu

### Cấp độ trung bình (11-15):
11. Chia 500 ÷ 100 trong 16 bit có dấu
12. Chia 1000 ÷ 200 trong 16 bit có dấu
13. Chia 1500 ÷ 300 trong 16 bit có dấu
14. Chia 2000 ÷ 400 trong 16 bit có dấu
15. Chia 0 ÷ 1 trong 16 bit có dấu

### Cấp độ nâng cao (16-20):
16. Chia 5000 ÷ 1000 trong 32 bit có dấu
17. Chia 10000 ÷ 2000 trong 32 bit có dấu
18. Chia 15000 ÷ 3000 trong 32 bit có dấu
19. Chia 20000 ÷ 4000 trong 32 bit có dấu
20. Chia 0 ÷ 1 trong 32 bit có dấu

---

## MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Chia như bình thường** trước
- **Kiểm tra tràn số** sau
- **Xử lý kết quả** theo yêu cầu
- **Nhớ công thức** tràn: kết quả > 2^(n-1) - 1 hoặc < -2^(n-1)

### LƯU Ý QUAN TRỌNG:
- **Tràn số** không phải lỗi, mà là đặc tính
- **Kết quả thực tế** = kết quả mod 2^n
- **Carry flag** = bit tràn (nếu có)
- **Kiểm tra** tràn trước khi sử dụng

### CÁCH KIỂM TRA:
- **Tính toán** kết quả trước
- **So sánh** với phạm vi bit
- **Xử lý** tràn nếu cần
- **Kiểm tra** bằng máy tính

### CÁC TRƯỜNG HỢP ĐẶC BIỆT:
- **A ÷ 1 = A** (chia cho 1)
- **A ÷ A = 1** (chia cho chính nó)
- **0 ÷ A = 0** (0 chia cho bất kỳ số nào)

### PHƯƠNG PHÁP NHANH:
1. **Chia** hai số
2. **Kiểm tra** tràn số
3. **Xử lý** kết quả
4. **Ghi** kết quả cuối cùng

### VÍ DỤ ỨNG DỤNG:
```cpp
// Phép chia số nguyên có dấu
struct SignedDivResult {
    int quotient;
    int remainder;
    bool overflow;
};

SignedDivResult signedDiv(int dividend, int divisor, int bits) {
    if (divisor == 0) {
        return {0, 0, true}; // Division by zero
    }
    
    int maxValue = (1 << (bits - 1)) - 1;
    int minValue = -(1 << (bits - 1));
    int quotient = dividend / divisor;
    int remainder = dividend % divisor;
    bool overflow = quotient > maxValue || quotient < minValue;
    
    if (overflow) {
        quotient = quotient & ((1 << bits) - 1);
    }
    
    return {quotient, remainder, overflow};
}

// Kiểm tra tràn số
bool checkOverflow(int dividend, int divisor, int bits) {
    if (divisor == 0) return true;
    int maxValue = (1 << (bits - 1)) - 1;
    int minValue = -(1 << (bits - 1));
    int quotient = dividend / divisor;
    return quotient > maxValue || quotient < minValue;
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Signed arithmetic
- **Assembly**: DIV instruction với carry flag
- **Counters**: Loop counters, array indices
- **Memory addressing**: Address calculations
- **Hash functions**: Checksum calculations

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 4.1: Biểu diễn số nguyên có dấu
