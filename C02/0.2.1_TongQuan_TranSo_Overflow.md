# üî¢ **0.2.1 T·ªîNG QUAN V·ªÄ TR√ÄN S·ªê (OVERFLOW)**

## **M·ª§C TI√äU**
- Hi·ªÉu kh√°i ni·ªám tr√†n s·ªë v√† c√°c lo·∫°i tr√†n s·ªë
- N·∫Øm v·ªØng ph∆∞∆°ng ph√°p x·ª≠ l√Ω tr√†n s·ªë
- So s√°nh tr√†n s·ªë gi·ªØa c√°c h·ªá th·ªëng bi·ªÉu di·ªÖn
- ·ª®ng d·ª•ng th·ª±c t·∫ø trong l·∫≠p tr√¨nh v√† ph·∫ßn c·ª©ng

---

## **L√ù THUY·∫æT C∆† B·∫¢N**

### **üîç ƒê·ªãnh nghƒ©a tr√†n s·ªë (Overflow)**
**Tr√†n s·ªë** l√† hi·ªán t∆∞·ª£ng khi k·∫øt qu·∫£ c·ªßa ph√©p to√°n v∆∞·ª£t qu√° ph·∫°m vi bi·ªÉu di·ªÖn c·ªßa s·ªë bit ƒë∆∞·ª£c c·∫•p ph√°t trong m√°y t√≠nh.

### **üìä C√°c lo·∫°i tr√†n s·ªë ch√≠nh:**

#### **1. Tr√†n s·ªë nguy√™n (Integer Overflow)**
- **Unsigned Integer Overflow**: K·∫øt qu·∫£ > 2^n - 1
- **Signed Integer Overflow**: K·∫øt qu·∫£ > 2^(n-1) - 1 ho·∫∑c < -2^(n-1)

#### **2. Tr√†n s·ªë th·ª±c (Floating Point Overflow)**
- **Overflow**: Exponent qu√° l·ªõn ‚Üí ¬±‚àû
- **Underflow**: Exponent qu√° nh·ªè ‚Üí 0 ho·∫∑c s·ªë kh√¥ng chu·∫©n h√≥a

#### **3. Tr√†n s·ªë d·∫•u ch·∫•m tƒ©nh (Fixed Point Overflow)**
- K·∫øt qu·∫£ v∆∞·ª£t qu√° ph·∫°m vi ph·∫ßn nguy√™n ƒë∆∞·ª£c c·∫•p ph√°t

---

## **üìã B·∫¢NG T·ªîNG H·ª¢P C√ÅC LO·∫†I TR√ÄN S·ªê**

| **Lo·∫°i** | **Ph·∫°m vi** | **ƒêi·ªÅu ki·ªán tr√†n** | **K·∫øt qu·∫£ th·ª±c t·∫ø** |
|----------|-------------|-------------------|-------------------|
| **Unsigned 4-bit** | 0 - 15 | > 15 | K·∫øt qu·∫£ mod 16 |
| **Unsigned 8-bit** | 0 - 255 | > 255 | K·∫øt qu·∫£ mod 256 |
| **Unsigned 16-bit** | 0 - 65535 | > 65535 | K·∫øt qu·∫£ mod 65536 |
| **Unsigned 32-bit** | 0 - 4294967295 | > 4294967295 | K·∫øt qu·∫£ mod 4294967296 |
| **Signed 4-bit** | -8 - 7 | > 7 ho·∫∑c < -8 | K·∫øt qu·∫£ mod 16 |
| **Signed 8-bit** | -128 - 127 | > 127 ho·∫∑c < -128 | K·∫øt qu·∫£ mod 256 |
| **Signed 16-bit** | -32768 - 32767 | > 32767 ho·∫∑c < -32768 | K·∫øt qu·∫£ mod 65536 |
| **Signed 32-bit** | -2147483648 - 2147483647 | > 2147483647 ho·∫∑c < -2147483648 | K·∫øt qu·∫£ mod 4294967296 |
| **IEEE 754 Single** | ¬±1.4√ó10‚Åª‚Å¥‚Åµ - ¬±3.4√ó10¬≥‚Å∏ | Exponent > 127 | ¬±‚àû |
| **IEEE 754 Double** | ¬±4.9√ó10‚Åª¬≥¬≤‚Å¥ - ¬±1.8√ó10¬≥‚Å∞‚Å∏ | Exponent > 1023 | ¬±‚àû |

---

## **üõ†Ô∏è PH∆Ø∆†NG PH√ÅP X·ª¨ L√ù TR√ÄN S·ªê**

### **üìã T·ªîNG QUAN C√ÅC PH∆Ø∆†NG PH√ÅP CH√çNH**

| **Ph∆∞∆°ng ph√°p** | **B·∫£n ch·∫•t** | **Th·ªùi ƒëi·ªÉm** | **C∆° ch·∫ø** | **∆Øu ƒëi·ªÉm** | **Nh∆∞·ª£c ƒëi·ªÉm** |
|----------------|--------------|---------------|------------|-------------|----------------|
| **Pre-check** | Ph√≤ng ng·ª´a | Tr∆∞·ªõc khi t√≠nh | Logic ƒëi·ªÅu ki·ªán | 100% ch√≠nh x√°c | T·ªën CPU cho ki·ªÉm tra |
| **Post-handle** | Ch·∫•p nh·∫≠n & ƒëi·ªÅu ch·ªânh | Sau khi t√≠nh | Modular arithmetic | Nhanh, ƒë∆°n gi·∫£n | C√≥ th·ªÉ m·∫•t th√¥ng tin |
| **Carry Flag** | Ph√°t hi·ªán t·ª± nhi√™n | Trong khi t√≠nh | Hardware flags | Mi·ªÖn ph√≠ (hardware) | Ch·ªâ d√πng ƒë∆∞·ª£c trong Assembly |

---

### **1. üîç KI·ªÇM TRA TR∆Ø·ªöC KHI T√çNH TO√ÅN (Pre-computation Check)**

#### **üéØ B·∫£n ch·∫•t:**
- **Nguy√™n l√Ω**: **Ph√≤ng ng·ª´a** (Prevention) - NgƒÉn ch·∫∑n tr√†n s·ªë x·∫£y ra
- **Tri·∫øt l√Ω**: "T·ªët h∆°n l√† ph√≤ng b·ªánh h∆°n ch·ªØa b·ªánh"
- **C∆° ch·∫ø**: S·ª≠ d·ª•ng **logic ƒëi·ªÅu ki·ªán** ƒë·ªÉ ki·ªÉm tra tr∆∞·ªõc khi th·ª±c hi·ªán

#### **üßÆ Nguy√™n l√Ω to√°n h·ªçc:**
```
Cho ph√©p c·ªông: a + b = c
ƒêi·ªÅu ki·ªán kh√¥ng tr√†n: c ‚â§ MAX_VALUE
‚Üí a + b ‚â§ MAX_VALUE
‚Üí a ‚â§ MAX_VALUE - b
```

#### **‚öôÔ∏è C√°c b∆∞·ªõc th·ª±c hi·ªán:**
1. **B∆∞·ªõc 1**: X√°c ƒë·ªãnh ph·∫°m vi cho ph√©p
2. **B∆∞·ªõc 2**: Ki·ªÉm tra ƒëi·ªÅu ki·ªán tr√†n
3. **B∆∞·ªõc 3**: X·ª≠ l√Ω khi ph√°t hi·ªán tr√†n

```cpp
// B∆∞·ªõc 1: X√°c ƒë·ªãnh ph·∫°m vi cho ph√©p
int maxValue = (1 << bits) - 1;  // 2^n - 1 (unsigned)
int maxValue = (1 << (bits - 1)) - 1;  // 2^(n-1) - 1 (signed)
int minValue = -(1 << (bits - 1));     // -2^(n-1) (signed)

// B∆∞·ªõc 2: Ki·ªÉm tra tr√†n s·ªë unsigned
bool checkUnsignedOverflow(int a, int b, int bits) {
    int maxValue = (1 << bits) - 1;
    return (a + b) > maxValue;
}

// B∆∞·ªõc 2: Ki·ªÉm tra tr√†n s·ªë signed
bool checkSignedOverflow(int a, int b, int bits) {
    int maxValue = (1 << (bits - 1)) - 1;
    int minValue = -(1 << (bits - 1));
    int sum = a + b;
    return sum > maxValue || sum < minValue;
}

// B∆∞·ªõc 3: X·ª≠ l√Ω khi ph√°t hi·ªán tr√†n
if (checkUnsignedOverflow(a, b, 8)) {
    // X·ª≠ l√Ω tr√†n s·ªë
    // C√≥ th·ªÉ: throw exception, return error, ho·∫∑c clamp value
    throw std::overflow_error("Unsigned overflow detected");
}
```

#### **üîç V√≠ d·ª• minh h·ªça b·∫£n ch·∫•t:**
```cpp
// B·∫£n ch·∫•t: Ki·ªÉm tra "c√≥ th·ªÉ" thay v√¨ "ƒë√£ x·∫£y ra"
if (a > MAX_VALUE - b) {  // D·ª± ƒëo√°n tr√†n s·ªë
    // X·ª≠ l√Ω tr∆∞·ªõc khi tr√†n x·∫£y ra
    throw std::overflow_error("S·∫Ω tr√†n!");
}
int result = a + b;  // An to√†n v√¨ ƒë√£ ki·ªÉm tra
```

---

### **2. üîÑ X·ª¨ L√ù SAU KHI T√çNH TO√ÅN (Post-computation Handling)**

#### **üéØ B·∫£n ch·∫•t:**
- **Nguy√™n l√Ω**: **Ch·∫•p nh·∫≠n v√† ƒëi·ªÅu ch·ªânh** (Accept and Adjust)
- **Tri·∫øt l√Ω**: "Tr√†n s·ªë l√† b√¨nh th∆∞·ªùng, ch·ªâ c·∫ßn x·ª≠ l√Ω ƒë√∫ng c√°ch"
- **C∆° ch·∫ø**: S·ª≠ d·ª•ng **modular arithmetic** (s·ªë h·ªçc m√¥-ƒëun)

#### **üßÆ Nguy√™n l√Ω to√°n h·ªçc:**
```
Khi tr√†n s·ªë x·∫£y ra: a + b = c (c > MAX_VALUE)
K·∫øt qu·∫£ th·ª±c t·∫ø: c mod (2^n) = c & ((1 << n) - 1)
```

#### **‚öôÔ∏è C√°c b∆∞·ªõc th·ª±c hi·ªán:**
1. **B∆∞·ªõc 1**: Th·ª±c hi·ªán ph√©p to√°n
2. **B∆∞·ªõc 2**: √Åp d·ª•ng modulo ƒë·ªÉ x·ª≠ l√Ω tr√†n
3. **B∆∞·ªõc 3**: Ki·ªÉm tra k·∫øt qu·∫£ cu·ªëi c√πng

```cpp
// B∆∞·ªõc 1: Th·ª±c hi·ªán ph√©p to√°n
int result = a + b;  // C√≥ th·ªÉ ƒë√£ b·ªã tr√†n

// B∆∞·ªõc 2: X·ª≠ l√Ω tr√†n s·ªë unsigned
int handleUnsignedOverflow(int result, int bits) {
    int maxValue = (1 << bits) - 1;
    return result & maxValue; // T∆∞∆°ng ƒë∆∞∆°ng result % (1 << bits)
}

// B∆∞·ªõc 2: X·ª≠ l√Ω tr√†n s·ªë signed
int handleSignedOverflow(int result, int bits) {
    int mask = (1 << bits) - 1;
    return result & mask;
}

// B∆∞·ªõc 3: Ki·ªÉm tra k·∫øt qu·∫£ cu·ªëi c√πng
int finalResult = handleUnsignedOverflow(result, 8);
// finalResult s·∫Ω n·∫±m trong ph·∫°m vi [0, 255] cho 8-bit unsigned
```

#### **üåä M√¥ h√¨nh "Quay v√≤ng" (Wraparound):**
```
Ph·∫°m vi 8-bit: [0, 1, 2, ..., 254, 255]
                    ‚Üë
                255 + 1 = 0
                0 - 1 = 255
```

#### **üîç V√≠ d·ª• minh h·ªça b·∫£n ch·∫•t:**
```cpp
// B·∫£n ch·∫•t: "Wrap-around" - quay v√≤ng trong kh√¥ng gian h·ªØu h·∫°n
int result = a + b;  // C√≥ th·ªÉ ƒë√£ tr√†n
int finalResult = result & MASK;  // ƒêi·ªÅu ch·ªânh v·ªÅ ph·∫°m vi h·ª£p l·ªá

// T∆∞∆°ng ƒë∆∞∆°ng: result % (2^n)
// V√≠ d·ª•: 300 % 256 = 44 (8-bit unsigned)
```

---

### **3. üèóÔ∏è S·ª¨ D·ª§NG CARRY FLAG (Assembly Level)**

#### **üéØ B·∫£n ch·∫•t:**
- **Nguy√™n l√Ω**: **Ph√°t hi·ªán ph·∫ßn c·ª©ng** (Hardware Detection)
- **Tri·∫øt l√Ω**: "ƒê·ªÉ ph·∫ßn c·ª©ng t·ª± nhi√™n x·ª≠ l√Ω"
- **C∆° ch·∫ø**: S·ª≠ d·ª•ng **carry bit** ƒë∆∞·ª£c t·∫°o ra t·ª± ƒë·ªông b·ªüi ALU

#### **üßÆ Nguy√™n l√Ω ph·∫ßn c·ª©ng:**
```
ALU th·ª±c hi·ªán: A + B = SUM
Carry Flag (CF) = 1 n·∫øu c√≥ bit tr√†n ra ngo√†i
Overflow Flag (OF) = 1 n·∫øu k·∫øt qu·∫£ kh√¥ng ƒë√∫ng d·∫•u (signed)
```

#### **‚öôÔ∏è C√°c b∆∞·ªõc th·ª±c hi·ªán:**
1. **B∆∞·ªõc 1**: Th·ª±c hi·ªán ph√©p c·ªông
2. **B∆∞·ªõc 2**: Ki·ªÉm tra carry flag
3. **B∆∞·ªõc 3**: X·ª≠ l√Ω t∆∞∆°ng ·ª©ng

```assembly
; B∆∞·ªõc 1: Th·ª±c hi·ªán ph√©p c·ªông
ADD AX, BX    ; ALU th·ª±c hi·ªán v√† set CF n·∫øu c·∫ßn

; B∆∞·ªõc 2: Ki·ªÉm tra carry flag
JC overflow_detected    ; Jump if Carry (c√≥ tr√†n)
JNC no_overflow        ; Jump if No Carry (kh√¥ng tr√†n)

; B∆∞·ªõc 3: X·ª≠ l√Ω t∆∞∆°ng ·ª©ng
overflow_detected:
    ; X·ª≠ l√Ω khi c√≥ tr√†n s·ªë
    ; C√≥ th·ªÉ: set error flag, log, ho·∫∑c handle gracefully
    
no_overflow:
    ; Ti·∫øp t·ª•c x·ª≠ l√Ω b√¨nh th∆∞·ªùng
```

#### **üîß C∆° ch·∫ø ph·∫ßn c·ª©ng:**
```
    1111 1111 (255)
  + 0000 0001 (1)
  -----------
  1 0000 0000 (256, nh∆∞ng ch·ªâ l∆∞u 0000 0000)
    ‚Üë
  Carry bit = 1 (bit tr√†n ra ngo√†i)
```

#### **üîç V√≠ d·ª• minh h·ªça b·∫£n ch·∫•t:**
```assembly
; B·∫£n ch·∫•t: Ph·∫ßn c·ª©ng t·ª± ƒë·ªông t·∫°o ra th√¥ng tin v·ªÅ tr√†n s·ªë
ADD AX, BX    ; ALU th·ª±c hi·ªán v√† set CF n·∫øu c·∫ßn
JC overflow   ; Ki·ªÉm tra carry flag do ph·∫ßn c·ª©ng t·∫°o ra
```

---

### **üìä SO S√ÅNH CHI TI·∫æT C√ÅC PH∆Ø∆†NG PH√ÅP**

| **Kh√≠a c·∫°nh** | **Pre-check** | **Post-handle** | **Carry Flag** |
|---------------|---------------|-----------------|----------------|
| **Tri·∫øt l√Ω** | Ph√≤ng ng·ª´a | Ch·∫•p nh·∫≠n & ƒëi·ªÅu ch·ªânh | Ph√°t hi·ªán t·ª± nhi√™n |
| **Th·ªùi ƒëi·ªÉm** | Tr∆∞·ªõc khi t√≠nh | Sau khi t√≠nh | Trong khi t√≠nh |
| **C∆° ch·∫ø** | Logic ƒëi·ªÅu ki·ªán | Modular arithmetic | Hardware flags |
| **Chi ph√≠** | T·ªën CPU cho ki·ªÉm tra | T·ªën CPU cho modulo | Mi·ªÖn ph√≠ (hardware) |
| **ƒê·ªô ch√≠nh x√°c** | 100% ch√≠nh x√°c | C√≥ th·ªÉ m·∫•t th√¥ng tin | Ph·ª• thu·ªôc x·ª≠ l√Ω |
| **Ph·∫°m vi** | Software | Software | Hardware/Assembly |
| **·ª®ng d·ª•ng** | T√†i ch√≠nh, Y t·∫ø | Game, Graphics | Embedded, Real-time |

---

### **üß† NGUY√äN L√ù S√ÇU H∆†N**

#### **1. Pre-check: Logic c·ªßa "Kh·∫£ nƒÉng"**
```cpp
// B·∫£n ch·∫•t: Ki·ªÉm tra "kh·∫£ nƒÉng" thay v√¨ "th·ª±c t·∫ø"
// To√°n h·ªçc: ‚àÄa,b: a + b ‚â§ MAX ‚Üí a ‚â§ MAX - b
if (a <= MAX_VALUE - b) {
    // "C√≥ th·ªÉ" th·ª±c hi·ªán an to√†n
    return a + b;
}
```

#### **2. Post-handle: Logic c·ªßa "V√≤ng tr√≤n"**
```cpp
// B·∫£n ch·∫•t: S·ªë h·ªçc trong kh√¥ng gian h·ªØu h·∫°n
// To√°n h·ªçc: (a + b) mod 2^n
// H√¨nh h·ªçc: ƒêi·ªÉm tr√™n v√≤ng tr√≤n c√≥ chu vi 2^n
int result = (a + b) & MASK;  // "Quay v√≤ng" v·ªÅ ph·∫°m vi
```

#### **3. Carry Flag: Logic c·ªßa "T·ª± nhi√™n"**
```assembly
; B·∫£n ch·∫•t: Ph·∫ßn c·ª©ng "bi·∫øt" khi n√†o tr√†n
; V·∫≠t l√Ω: Bit tr√†n ra ngo√†i thanh ghi
; T·ª± ƒë·ªông: ALU t·ª± ƒë·ªông t·∫°o ra th√¥ng tin n√†y
ADD AX, BX  ; Hardware t·ª± ƒë·ªông set CF
```

---

### **üîß ·ª®NG D·ª§NG TH·ª∞C T·∫æ TRONG L·∫¨P TR√åNH**

#### **C/C++ Implementation**
```cpp
#include <iostream>
#include <stdexcept>

class OverflowHandler {
public:
    // Ph∆∞∆°ng ph√°p 1: Ki·ªÉm tra tr∆∞·ªõc
    static int safeAdd(int a, int b, int bits) {
        int maxValue = (1 << bits) - 1;
        if (a > maxValue - b) {
            throw std::overflow_error("Addition would overflow");
        }
        return a + b;
    }
    
    // Ph∆∞∆°ng ph√°p 2: X·ª≠ l√Ω sau
    static int wrapAdd(int a, int b, int bits) {
        int result = a + b;
        int mask = (1 << bits) - 1;
        return result & mask;
    }
    
    // Ph∆∞∆°ng ph√°p 3: Clamp (gi·ªõi h·∫°n)
    static int clampAdd(int a, int b, int bits) {
        int result = a + b;
        int maxValue = (1 << bits) - 1;
        return (result > maxValue) ? maxValue : result;
    }
};
```

#### **Java Implementation**
```java
public class OverflowHandler {
    // Ph∆∞∆°ng ph√°p 1: Ki·ªÉm tra tr∆∞·ªõc
    public static int safeAdd(int a, int b, int bits) {
        int maxValue = (1 << bits) - 1;
        if (a > maxValue - b) {
            throw new ArithmeticException("Addition would overflow");
        }
        return a + b;
    }
    
    // Ph∆∞∆°ng ph√°p 2: X·ª≠ l√Ω sau (Java t·ª± ƒë·ªông wrap)
    public static int wrapAdd(int a, int b, int bits) {
        int result = a + b;
        int mask = (1 << bits) - 1;
        return result & mask;
    }
}
```

---

### **üéØ ·ª®NG D·ª§NG B·∫¢N CH·∫§T TRONG TH·ª∞C T·∫æ**

#### **Pre-check: Khi c·∫ßn "Ho√†n h·∫£o"**
- **T√†i ch√≠nh**: Kh√¥ng ƒë∆∞·ª£c ph√©p m·∫•t ti·ªÅn do tr√†n s·ªë
- **Y t·∫ø**: T√≠nh to√°n li·ªÅu thu·ªëc ph·∫£i ch√≠nh x√°c 100%
- **H√†ng kh√¥ng**: T√≠nh to√°n qu·ªπ ƒë·∫°o kh√¥ng ƒë∆∞·ª£c sai

#### **Post-handle: Khi ch·∫•p nh·∫≠n "T∆∞∆°ng ƒë·ªëi"**
- **Game**: Wrap-around t·∫°o hi·ªáu ·ª©ng "v√¥ h·∫°n"
- **Graphics**: Pixel values c√≥ th·ªÉ wrap-around
- **Audio**: Sample values c√≥ th·ªÉ wrap-around

#### **Carry Flag: Khi c·∫ßn "Hi·ªáu qu·∫£"**
- **Embedded systems**: T√†i nguy√™n h·∫°n ch·∫ø
- **Real-time systems**: C·∫ßn ph·∫£n ·ª©ng nhanh
- **Assembly programming**: Ki·ªÉm so√°t t·ªëi ƒëa

---

### **‚ö†Ô∏è L∆ØU √ù QUAN TR·ªåNG KHI X·ª¨ L√ù TR√ÄN S·ªê**

#### **1. Ch·ªçn ph∆∞∆°ng ph√°p ph√π h·ª£p**
- **Pre-check**: Khi c·∫ßn ƒë·∫£m b·∫£o kh√¥ng c√≥ tr√†n s·ªë
- **Post-handle**: Khi ch·∫•p nh·∫≠n tr√†n s·ªë nh∆∞ng c·∫ßn k·∫øt qu·∫£ h·ª£p l·ªá
- **Carry Flag**: Khi l√†m vi·ªác ·ªü m·ª©c Assembly/hardware

#### **2. Xem x√©t ng·ªØ c·∫£nh ·ª©ng d·ª•ng**
- **T√≠nh to√°n t√†i ch√≠nh**: C·∫ßn ƒë·ªô ch√≠nh x√°c cao ‚Üí Pre-check
- **Game/Graphics**: C√≥ th·ªÉ ch·∫•p nh·∫≠n wrap-around ‚Üí Post-handle
- **Embedded systems**: C·∫ßn hi·ªáu su·∫•t cao ‚Üí Carry Flag

#### **3. Debugging v√† Testing**
```cpp
// Unit test cho overflow handling
void testOverflowHandling() {
    // Test case 1: Kh√¥ng tr√†n
    assert(safeAdd(100, 150, 8) == 250);
    
    // Test case 2: C√≥ tr√†n
    assert(wrapAdd(200, 100, 8) == 44);
    
    // Test case 3: Boundary values
    assert(safeAdd(255, 0, 8) == 255);
}
```

---

## **üìù V√ç D·ª§ MINH H·ªåA CHI TI·∫æT**

### **V√≠ d·ª• 1: Tr√†n s·ªë unsigned 4-bit - √Åp d·ª•ng c√°c ph∆∞∆°ng ph√°p**

**B√†i to√°n:** 10 + 8 = ?

**Ph·∫°m vi 4-bit unsigned:** 0 - 15

#### **Ph∆∞∆°ng ph√°p 1: Pre-check**
```cpp
// B∆∞·ªõc 1: X√°c ƒë·ªãnh ph·∫°m vi
int maxValue = (1 << 4) - 1;  // 15

// B∆∞·ªõc 2: Ki·ªÉm tra tr∆∞·ªõc khi t√≠nh
bool willOverflow = (10 + 8) > 15;  // true
if (willOverflow) {
    cout << "S·∫Ω c√≥ tr√†n s·ªë!" << endl;
    // X·ª≠ l√Ω: throw exception ho·∫∑c clamp
}

// B∆∞·ªõc 3: N·∫øu kh√¥ng tr√†n, th·ª±c hi·ªán an to√†n
if (!willOverflow) {
    int result = 10 + 8;  // Kh√¥ng bao gi·ªù ƒë·∫øn ƒë√¢y
}
```

#### **Ph∆∞∆°ng ph√°p 2: Post-handle**
```cpp
// B∆∞·ªõc 1: Th·ª±c hi·ªán ph√©p to√°n
int result = 10 + 8;  // 18

// B∆∞·ªõc 2: X·ª≠ l√Ω tr√†n s·ªë
int finalResult = result & 0xF;  // 18 & 15 = 2

// B∆∞·ªõc 3: K·∫øt qu·∫£ cu·ªëi c√πng
cout << "K·∫øt qu·∫£: " << finalResult << endl;  // 2
```

#### **Ph∆∞∆°ng ph√°p 3: Carry Flag (Assembly)**
```assembly
; B∆∞·ªõc 1: Load values
MOV AL, 10    ; AL = 10 (1010‚ÇÇ)
MOV BL, 8     ; BL = 8  (1000‚ÇÇ)

; B∆∞·ªõc 2: Th·ª±c hi·ªán ph√©p c·ªông
ADD AL, BL    ; AL = 18 (10010‚ÇÇ), CF = 1

; B∆∞·ªõc 3: Ki·ªÉm tra carry flag
JC overflow_detected    ; Jump if Carry = 1

overflow_detected:
    ; X·ª≠ l√Ω tr√†n s·ªë
    AND AL, 0xF    ; AL = 2 (0010‚ÇÇ)
```

**T√≠nh to√°n chi ti·∫øt:**
```
  1010‚ÇÇ (10‚ÇÅ‚ÇÄ)
+ 1000‚ÇÇ (8‚ÇÅ‚ÇÄ)
-------
 10010‚ÇÇ (18‚ÇÅ‚ÇÄ)
    ‚Üë
  Carry bit = 1 (bit tr√†n ra ngo√†i)

K·∫øt qu·∫£ th·ª±c t·∫ø: 18 mod 16 = 2
‚Üí 10 + 8 = 2 (4-bit unsigned, c√≥ tr√†n)
```

---

### **V√≠ d·ª• 2: Tr√†n s·ªë signed 4-bit - So s√°nh c√°c ph∆∞∆°ng ph√°p**

**B√†i to√°n:** 5 + 3 = ?

**Ph·∫°m vi 4-bit signed:** -8 - 7

#### **Ph∆∞∆°ng ph√°p 1: Pre-check**
```cpp
// B∆∞·ªõc 1: X√°c ƒë·ªãnh ph·∫°m vi
int maxValue = (1 << (4-1)) - 1;  // 7
int minValue = -(1 << (4-1));     // -8

// B∆∞·ªõc 2: Ki·ªÉm tra tr∆∞·ªõc khi t√≠nh
int sum = 5 + 3;  // 8
bool willOverflow = (sum > 7);  // true
if (willOverflow) {
    cout << "S·∫Ω c√≥ tr√†n s·ªë!" << endl;
}
```

#### **Ph∆∞∆°ng ph√°p 2: Post-handle**
```cpp
// B∆∞·ªõc 1: Th·ª±c hi·ªán ph√©p to√°n
int result = 5 + 3;  // 8

// B∆∞·ªõc 2: X·ª≠ l√Ω tr√†n s·ªë
int finalResult = result & 0xF;  // 8 & 15 = 8

// B∆∞·ªõc 3: K·∫øt qu·∫£ cu·ªëi c√πng
cout << "K·∫øt qu·∫£: " << finalResult << endl;  // 8
```

**T√≠nh to√°n chi ti·∫øt:**
```
  0101‚ÇÇ (5‚ÇÅ‚ÇÄ)
+ 0011‚ÇÇ (3‚ÇÅ‚ÇÄ)
-------
  1000‚ÇÇ (8‚ÇÅ‚ÇÄ)

Ki·ªÉm tra tr√†n: 8 > 7 ‚úó ‚Üí C√≥ tr√†n s·ªë
K·∫øt qu·∫£ th·ª±c t·∫ø: 8 mod 16 = 8
‚Üí 5 + 3 = 8 (4-bit signed, c√≥ tr√†n)
```

---

### **V√≠ d·ª• 3: Floating Point Overflow**

**B√†i to√°n:** 0.9 √ó 10¬π‚Å∞‚Å∞

**IEEE 754 Single Precision:** Exponent bias = 127

#### **Ph∆∞∆°ng ph√°p x·ª≠ l√Ω:**
```cpp
// B∆∞·ªõc 1: Ki·ªÉm tra exponent
float base = 0.9f;
int exponent = 100;

// B∆∞·ªõc 2: So s√°nh v·ªõi gi·ªõi h·∫°n
if (exponent > 127) {  // 100 > 127
    cout << "Floating point overflow!" << endl;
    // K·∫øt qu·∫£: +‚àû (d∆∞∆°ng v√¥ c·ª±c)
}

// B∆∞·ªõc 3: X·ª≠ l√Ω k·∫øt qu·∫£
float result = (exponent > 127) ? INFINITY : base * pow(10, exponent);
```

**K·∫øt qu·∫£:** +‚àû (d∆∞∆°ng v√¥ c·ª±c)

---

### **V√≠ d·ª• 4: So s√°nh hi·ªáu qu·∫£ c√°c ph∆∞∆°ng ph√°p**

**B√†i to√°n:** 200 + 100 (8-bit unsigned)

#### **Ph∆∞∆°ng ph√°p 1: Pre-check (An to√†n nh·∫•t)**
```cpp
int a = 200, b = 100;
int maxValue = 255;

// Ki·ªÉm tra tr∆∞·ªõc
if (a > maxValue - b) {  // 200 > 155
    throw std::overflow_error("Overflow detected");
}
// Kh√¥ng bao gi·ªù th·ª±c hi·ªán ph√©p c·ªông
```

#### **Ph∆∞∆°ng ph√°p 2: Post-handle (Nhanh nh·∫•t)**
```cpp
int a = 200, b = 100;
int result = a + b;  // 300
int finalResult = result & 0xFF;  // 44
// K·∫øt qu·∫£: 44
```

#### **Ph∆∞∆°ng ph√°p 3: Carry Flag (Hi·ªáu qu·∫£ nh·∫•t)**
```assembly
MOV AL, 200    ; AL = 200
MOV BL, 100    ; BL = 100
ADD AL, BL     ; AL = 44, CF = 1
JC handle_overflow
```

**So s√°nh:**
- **Pre-check**: An to√†n 100%, nh∆∞ng t·ªën CPU
- **Post-handle**: Nhanh, nh∆∞ng c√≥ th·ªÉ m·∫•t th√¥ng tin
- **Carry Flag**: Hi·ªáu qu·∫£, nh∆∞ng ch·ªâ d√πng ƒë∆∞·ª£c trong Assembly

---

## **üéØ C√ÅC TR∆Ø·ªúNG H·ª¢P ƒê·∫∂C BI·ªÜT**

### **1. Tr√†n ho√†n to√†n (Complete Overflow)**
```
Unsigned: 2^n - 1 + 1 = 0
Signed: 2^(n-1) - 1 + 1 = -2^(n-1)
```

### **2. Tr√†n m·ªôt ph·∫ßn (Partial Overflow)**
```
K·∫øt qu·∫£ v∆∞·ª£t qu√° ph·∫°m vi nh∆∞ng kh√¥ng qu√° xa
‚Üí K·∫øt qu·∫£ = k·∫øt qu·∫£ mod 2^n
```

### **3. Tr√†n √¢m (Negative Overflow)**
```
Ch·ªâ x·∫£y ra v·ªõi s·ªë c√≥ d·∫•u
K·∫øt qu·∫£ < -2^(n-1)
```

---

## **üîß ·ª®NG D·ª§NG TH·ª∞C T·∫æ**

### **1. Trong l·∫≠p tr√¨nh**
```cpp
// C/C++: Integer overflow
int a = 2147483647;  // INT_MAX
int b = a + 1;       // Overflow ‚Üí -2147483648

// Java: Automatic overflow handling
int result = Integer.MAX_VALUE + 1;  // Wraps around
```

### **2. Trong Assembly**
```assembly
; x86 Assembly
MOV AX, 32767    ; Load max 16-bit signed
ADD AX, 1        ; Overflow ‚Üí -32768
JO overflow_handler  ; Jump if Overflow
```

### **3. Trong ph·∫ßn c·ª©ng**
- **CPU**: Arithmetic Logic Unit (ALU) v·ªõi carry flag
- **Microcontrollers**: Overflow detection circuits
- **Graphics**: Pixel value clamping
- **Audio**: Sample range limiting

---

## **‚ö†Ô∏è L∆ØU √ù QUAN TR·ªåNG**

### **1. Tr√†n s·ªë kh√¥ng ph·∫£i l·ªói**
- L√† **ƒë·∫∑c t√≠nh** c·ªßa h·ªá th·ªëng s·ªë c√≥ gi·ªõi h·∫°n
- C·∫ßn **x·ª≠ l√Ω ph√π h·ª£p** cho t·ª´ng ·ª©ng d·ª•ng
- **Ki·ªÉm tra** tr∆∞·ªõc khi s·ª≠ d·ª•ng k·∫øt qu·∫£

### **2. C√°c ph∆∞∆°ng ph√°p ph√≤ng ng·ª´a**
- **Ki·ªÉm tra ph·∫°m vi** tr∆∞·ªõc khi t√≠nh to√°n
- **S·ª≠ d·ª•ng ki·ªÉu d·ªØ li·ªáu** ph√π h·ª£p
- **X·ª≠ l√Ω ngo·∫°i l·ªá** khi c√≥ tr√†n s·ªë
- **Thi·∫øt k·∫ø thu·∫≠t to√°n** tr√°nh tr√†n s·ªë

### **3. Debugging tr√†n s·ªë**
- **S·ª≠ d·ª•ng debugger** v·ªõi overflow detection
- **Ki·ªÉm tra carry flag** trong Assembly
- **Logging** c√°c ph√©p to√°n c√≥ th·ªÉ tr√†n
- **Unit testing** v·ªõi boundary values

---

## **üìö T√ÄI LI·ªÜU THAM KH·∫¢O CHI TI·∫æT**

### **üî¢ S·ªë nguy√™n kh√¥ng d·∫•u:**
- [3.1.2 Ph√©p c·ªông s·ªë nguy√™n kh√¥ng d·∫•u](3.1.2_PhepCong_SoNguyen_KhongDau.md)
- [3.1.4 Ph√©p nh√¢n s·ªë nguy√™n kh√¥ng d·∫•u](3.1.4_PhepNhan_SoNguyen_KhongDau.md)
- [3.1.5 Ph√©p chia s·ªë nguy√™n kh√¥ng d·∫•u](3.1.5_PhepChia_SoNguyen_KhongDau.md)
- [3.1.8 Ph·∫°m vi s·ªë nguy√™n kh√¥ng d·∫•u](3.1.8_PhamVi_SoNguyen_KhongDau.md)

### **‚ûñ S·ªë nguy√™n c√≥ d·∫•u:**
- [4.1.2 Ph√©p c·ªông s·ªë nguy√™n c√≥ d·∫•u](4.1.2_PhepCong_SoNguyen_CoDau.md)
- [4.1.3 Ph√©p tr·ª´ s·ªë nguy√™n c√≥ d·∫•u](4.1.3_PhepTru_SoNguyen_CoDau.md)
- [4.1.4 Ph√©p nh√¢n s·ªë nguy√™n c√≥ d·∫•u](4.1.4_PhepNhan_SoNguyen_CoDau.md)
- [4.1.5 Ph√©p chia s·ªë nguy√™n c√≥ d·∫•u](4.1.5_PhepChia_SoNguyen_CoDau.md)
- [4.1.8 Ph·∫°m vi s·ªë nguy√™n c√≥ d·∫•u](4.1.8_PhamVi_SoNguyen_CoDau.md)

### **üî¢ S·ªë th·ª±c:**
- [6.1.1 S·ªë d·∫•u ch·∫•m tƒ©nh](6.1.1_SoDauChamTinh_FixedPoint.md)
- [6.2.1 S·ªë d·∫•u ch·∫•m ƒë·ªông](6.2.1_SoDauChamDong_FloatingPoint.md)
- [6.3.1 IEEE 754 Single Precision](6.3.1_IEEE754_Single_Precision.md)
- [6.3.2 IEEE 754 Double Precision](6.3.2_IEEE754_DoublePrecision.md)

---

## **üéØ B√ÄI T·∫¨P T·ª∞ LUY·ªÜN**

### **C·∫•p ƒë·ªô c∆° b·∫£n:**
1. X√°c ƒë·ªãnh ph·∫°m vi c·ªßa s·ªë 8-bit unsigned v√† signed
2. Ki·ªÉm tra tr√†n s·ªë: 200 + 100 (8-bit unsigned)
3. Ki·ªÉm tra tr√†n s·ªë: 100 + 50 (8-bit signed)
4. T√≠nh k·∫øt qu·∫£ th·ª±c t·∫ø khi c√≥ tr√†n s·ªë

### **C·∫•p ƒë·ªô trung b√¨nh:**
5. So s√°nh tr√†n s·ªë gi·ªØa unsigned v√† signed
6. X·ª≠ l√Ω tr√†n s·ªë trong ph√©p nh√¢n
7. Ki·ªÉm tra overflow/underflow trong IEEE 754
8. Thi·∫øt k·∫ø h√†m ki·ªÉm tra tr√†n s·ªë t·ªïng qu√°t

### **C·∫•p ƒë·ªô n√¢ng cao:**
9. ·ª®ng d·ª•ng tr√†n s·ªë trong cryptography
10. T·ªëi ∆∞u h√≥a x·ª≠ l√Ω tr√†n s·ªë trong embedded systems
11. Debugging tr√†n s·ªë trong production code
12. Thi·∫øt k·∫ø h·ªá th·ªëng s·ªë tr√°nh tr√†n s·ªë

---

## **üìä T√ìM T·∫ÆT TO√ÄN DI·ªÜN**

### **üî¢ Tr√†n s·ªë l√† g√¨?**
**Tr√†n s·ªë** l√† hi·ªán t∆∞·ª£ng khi k·∫øt qu·∫£ c·ªßa ph√©p to√°n v∆∞·ª£t qu√° ph·∫°m vi bi·ªÉu di·ªÖn c·ªßa s·ªë bit ƒë∆∞·ª£c c·∫•p ph√°t trong m√°y t√≠nh.

### **üõ†Ô∏è Ba ph∆∞∆°ng ph√°p x·ª≠ l√Ω ch√≠nh:**

#### **1. üîç Pre-check (Ki·ªÉm tra tr∆∞·ªõc)**
- **B·∫£n ch·∫•t**: Ph√≤ng ng·ª´a - NgƒÉn ch·∫∑n tr√†n s·ªë x·∫£y ra
- **C∆° ch·∫ø**: Logic ƒëi·ªÅu ki·ªán + d·ª± ƒëo√°n
- **∆Øu ƒëi·ªÉm**: 100% ch√≠nh x√°c, an to√†n tuy·ªát ƒë·ªëi
- **Nh∆∞·ª£c ƒëi·ªÉm**: T·ªën CPU cho ki·ªÉm tra
- **·ª®ng d·ª•ng**: T√†i ch√≠nh, Y t·∫ø, H√†ng kh√¥ng

#### **2. üîÑ Post-handle (X·ª≠ l√Ω sau)**
- **B·∫£n ch·∫•t**: Ch·∫•p nh·∫≠n v√† ƒëi·ªÅu ch·ªânh
- **C∆° ch·∫ø**: Modular arithmetic + wraparound
- **∆Øu ƒëi·ªÉm**: Nhanh, ƒë∆°n gi·∫£n
- **Nh∆∞·ª£c ƒëi·ªÉm**: C√≥ th·ªÉ m·∫•t th√¥ng tin
- **·ª®ng d·ª•ng**: Game, Graphics, Audio

#### **3. ‚ö° Carry Flag (Ph√°t hi·ªán t·ª± nhi√™n)**
- **B·∫£n ch·∫•t**: Ph√°t hi·ªán ph·∫ßn c·ª©ng
- **C∆° ch·∫ø**: Hardware flags + automatic detection
- **∆Øu ƒëi·ªÉm**: Mi·ªÖn ph√≠ (hardware), hi·ªáu qu·∫£
- **Nh∆∞·ª£c ƒëi·ªÉm**: Ch·ªâ d√πng ƒë∆∞·ª£c trong Assembly
- **·ª®ng d·ª•ng**: Embedded systems, Real-time

### **üéØ T·∫ßm quan tr·ªçng c·ªßa tr√†n s·ªë:**

**Trong c√°c lƒ©nh v·ª±c:**
- **L·∫≠p tr√¨nh**: C·∫ßn hi·ªÉu ƒë·ªÉ tr√°nh bug v√† vi·∫øt code an to√†n
- **Ph·∫ßn c·ª©ng**: Thi·∫øt k·∫ø ALU v√† CPU hi·ªáu qu·∫£
- **To√°n h·ªçc**: Modular arithmetic v√† s·ªë h·ªçc h·ªØu h·∫°n
- **B·∫£o m·∫≠t**: Integer overflow vulnerabilities
- **Khoa h·ªçc m√°y t√≠nh**: Hi·ªÉu s√¢u v·ªÅ c√°ch m√°y t√≠nh x·ª≠ l√Ω s·ªë

**L·ª£i √≠ch khi h·ªçc tr√†n s·ªë:**
- ‚úÖ **Hi·ªÉu s√¢u** v·ªÅ c√°ch m√°y t√≠nh x·ª≠ l√Ω s·ªë
- ‚úÖ **Vi·∫øt code** an to√†n v√† hi·ªáu qu·∫£
- ‚úÖ **Debug** c√°c l·ªói li√™n quan ƒë·∫øn s·ªë h·ªçc
- ‚úÖ **Thi·∫øt k·∫ø** h·ªá th·ªëng s·ªë h·ªçc ch√≠nh x√°c
- ‚úÖ **T·ªëi ∆∞u h√≥a** hi·ªáu su·∫•t trong embedded systems
- ‚úÖ **Ph√≤ng ch·ªëng** l·ªó h·ªïng b·∫£o m·∫≠t do tr√†n s·ªë

### **üí° Nguy√™n l√Ω c·ªët l√µi:**
M·ªói ph∆∞∆°ng ph√°p ph·∫£n √°nh m·ªôt **tri·∫øt l√Ω kh√°c nhau** trong vi·ªác ƒë·ªëi ph√≥ v·ªõi tr√†n s·ªë:
- **Ph√≤ng ng·ª´a**: "T·ªët h∆°n l√† ph√≤ng b·ªánh h∆°n ch·ªØa b·ªánh"
- **Ch·∫•p nh·∫≠n**: "Tr√†n s·ªë l√† b√¨nh th∆∞·ªùng, ch·ªâ c·∫ßn x·ª≠ l√Ω ƒë√∫ng c√°ch"
- **Ph√°t hi·ªán t·ª± nhi√™n**: "ƒê·ªÉ ph·∫ßn c·ª©ng t·ª± nhi√™n x·ª≠ l√Ω"

---

**üìÖ C·∫≠p nh·∫≠t l·∫ßn cu·ªëi:** Th√°ng 1, 2025

---

*üéì **Nh·∫≠p M√¥n Tin H·ªçc, 2025** - *GVHD: Th.S V√µ Vi·ªát Khoa* - *Khoa CNTT - Tr∆∞·ªùng ƒê·∫°i H·ªçc M·ªü TP. H·ªì Ch√≠ Minh*
