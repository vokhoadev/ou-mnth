# 3.1.2 PHÉP CỘNG SỐ NGUYÊN KHÔNG DẤU

## Mô tả dạng bài tập
Thực hiện phép cộng giữa hai số nguyên không dấu và xử lý tràn số (overflow).

## Phương pháp giải

### Phương pháp 1: Cộng trực tiếp
1. **Cộng hai số** như bình thường
2. **Kiểm tra tràn số** (overflow)
3. **Xử lý kết quả** theo yêu cầu

### Phương pháp 2: Xử lý tràn số
1. **Tràn số**: kết quả > 2^n - 1
2. **Kết quả thực tế**: kết quả mod 2^n
3. **Carry flag**: bit tràn (nếu có)

## Bảng tràn số:
| Số bit | Phạm vi | Tràn khi |
|--------|---------|----------|
| 4      | 0-15    | > 15     |
| 8      | 0-255   | > 255    |
| 16     | 0-65535 | > 65535  |
| 32     | 0-4294967295 | > 4294967295 |

---

## BÀI TẬP CÓ LỜI GIẢI CHI TIẾT (10 bài)

### Bài 1: Cộng 5 + 7 trong 4 bit không dấu

**Lời giải:**
```
  0101₂ (5₁₀)
+ 0111₂ (7₁₀)
-------
  1100₂ (12₁₀)

Kiểm tra tràn:
5 + 7 = 12 ≤ 15 (2⁴ - 1) ✓
Không tràn số

Kết quả: 5 + 7 = 12 (4 bit không dấu)
```

### Bài 2: Cộng 10 + 8 trong 4 bit không dấu

**Lời giải:**
```
  1010₂ (10₁₀)
+ 1000₂ (8₁₀)
-------
 10010₂ (18₁₀)

Kiểm tra tràn:
10 + 8 = 18 > 15 (2⁴ - 1) ✗
Có tràn số

Kết quả thực tế: 18 mod 16 = 2
Kết quả: 10 + 8 = 2 (4 bit không dấu, có tràn)
```

### Bài 3: Cộng 100 + 150 trong 8 bit không dấu

**Lời giải:**
```
  01100100₂ (100₁₀)
+ 10010110₂ (150₁₀)
-------
  11111010₂ (250₁₀)

Kiểm tra tràn:
100 + 150 = 250 ≤ 255 (2⁸ - 1) ✓
Không tràn số

Kết quả: 100 + 150 = 250 (8 bit không dấu)
```

### Bài 4: Cộng 200 + 100 trong 8 bit không dấu

**Lời giải:**
```
  11001000₂ (200₁₀)
+ 01100100₂ (100₁₀)
-------
 100101100₂ (300₁₀)

Kiểm tra tràn:
200 + 100 = 300 > 255 (2⁸ - 1) ✗
Có tràn số

Kết quả thực tế: 300 mod 256 = 44
Kết quả: 200 + 100 = 44 (8 bit không dấu, có tràn)
```

### Bài 5: Cộng 255 + 1 trong 8 bit không dấu

**Lời giải:**
```
  11111111₂ (255₁₀)
+ 00000001₂ (1₁₀)
-------
 100000000₂ (256₁₀)

Kiểm tra tràn:
255 + 1 = 256 > 255 (2⁸ - 1) ✗
Có tràn số

Kết quả thực tế: 256 mod 256 = 0
Kết quả: 255 + 1 = 0 (8 bit không dấu, có tràn)
```

### Bài 6: Cộng 1000 + 2000 trong 16 bit không dấu

**Lời giải:**
```
  0000001111101000₂ (1000₁₀)
+ 0000011111010000₂ (2000₁₀)
-------
  0000101110111000₂ (3000₁₀)

Kiểm tra tràn:
1000 + 2000 = 3000 ≤ 65535 (2¹⁶ - 1) ✓
Không tràn số

Kết quả: 1000 + 2000 = 3000 (16 bit không dấu)
```

### Bài 7: Cộng 50000 + 20000 trong 16 bit không dấu

**Lời giải:**
```
  1100001101010000₂ (50000₁₀)
+ 0100111000100000₂ (20000₁₀)
-------
 1000100101110000₂ (70000₁₀)

Kiểm tra tràn:
50000 + 20000 = 70000 > 65535 (2¹⁶ - 1) ✗
Có tràn số

Kết quả thực tế: 70000 mod 65536 = 4464
Kết quả: 50000 + 20000 = 4464 (16 bit không dấu, có tràn)
```

### Bài 8: Cộng 65535 + 1 trong 16 bit không dấu

**Lời giải:**
```
  1111111111111111₂ (65535₁₀)
+ 0000000000000001₂ (1₁₀)
-------
 10000000000000000₂ (65536₁₀)

Kiểm tra tràn:
65535 + 1 = 65536 > 65535 (2¹⁶ - 1) ✗
Có tràn số

Kết quả thực tế: 65536 mod 65536 = 0
Kết quả: 65535 + 1 = 0 (16 bit không dấu, có tràn)
```

### Bài 9: Cộng 1000000 + 2000000 trong 32 bit không dấu

**Lời giải:**
```
  00000000000011110100001001000000₂ (1000000₁₀)
+ 00000000000111101000010010000000₂ (2000000₁₀)
-------
  00000000001011011100011011000000₂ (3000000₁₀)

Kiểm tra tràn:
1000000 + 2000000 = 3000000 ≤ 4294967295 (2³² - 1) ✓
Không tràn số

Kết quả: 1000000 + 2000000 = 3000000 (32 bit không dấu)
```

### Bài 10: Cộng 4294967295 + 1 trong 32 bit không dấu

**Lời giải:**
```
  11111111111111111111111111111111₂ (4294967295₁₀)
+ 00000000000000000000000000000001₂ (1₁₀)
-------
 100000000000000000000000000000000₂ (4294967296₁₀)

Kiểm tra tràn:
4294967295 + 1 = 4294967296 > 4294967295 (2³² - 1) ✗
Có tràn số

Kết quả thực tế: 4294967296 mod 4294967296 = 0
Kết quả: 4294967295 + 1 = 0 (32 bit không dấu, có tràn)
```

---

## BÀI TẬP TỰ RÈN LUYỆN (20 bài)

### Cấp độ cơ bản (1-10):
1. Cộng 3 + 5 trong 4 bit không dấu
2. Cộng 7 + 9 trong 4 bit không dấu
3. Cộng 12 + 4 trong 4 bit không dấu
4. Cộng 15 + 1 trong 4 bit không dấu
5. Cộng 0 + 0 trong 4 bit không dấu
6. Cộng 50 + 100 trong 8 bit không dấu
7. Cộng 150 + 200 trong 8 bit không dấu
8. Cộng 250 + 10 trong 8 bit không dấu
9. Cộng 255 + 0 trong 8 bit không dấu
10. Cộng 0 + 255 trong 8 bit không dấu

### Cấp độ trung bình (11-15):
11. Cộng 1000 + 5000 trong 16 bit không dấu
12. Cộng 10000 + 20000 trong 16 bit không dấu
13. Cộng 50000 + 10000 trong 16 bit không dấu
14. Cộng 60000 + 5000 trong 16 bit không dấu
15. Cộng 65535 + 0 trong 16 bit không dấu

### Cấp độ nâng cao (16-20):
16. Cộng 1000000 + 5000000 trong 32 bit không dấu
17. Cộng 10000000 + 20000000 trong 32 bit không dấu
18. Cộng 50000000 + 10000000 trong 32 bit không dấu
19. Cộng 100000000 + 50000000 trong 32 bit không dấu
20. Cộng 4294967295 + 0 trong 32 bit không dấu

---

## MẸO VÀ LƯU Ý

### MẸO LÀM NHANH:
- **Cộng như bình thường** trước
- **Kiểm tra tràn số** sau
- **Xử lý kết quả** theo yêu cầu
- **Nhớ công thức** tràn: kết quả > 2^n - 1

### LƯU Ý QUAN TRỌNG:
- **Tràn số** không phải lỗi, mà là đặc tính
- **Kết quả thực tế** = kết quả mod 2^n
- **Carry flag** = bit tràn (nếu có)
- **Kiểm tra** tràn trước khi sử dụng

### CÁCH KIỂM TRA:
- **Tính toán** kết quả trước
- **So sánh** với phạm vi bit
- **Xử lý** tràn nếu cần
- **Kiểm tra** bằng máy tính

### CÁC TRƯỜNG HỢP ĐẶC BIỆT:
- **A + 0 = A** (cộng với 0)
- **A + A = 2A** (cộng với chính nó)
- **2^n - 1 + 1 = 0** (tràn hoàn toàn)

### PHƯƠNG PHÁP NHANH:
1. **Cộng** hai số
2. **Kiểm tra** tràn số
3. **Xử lý** kết quả
4. **Ghi** kết quả cuối cùng

### VÍ DỤ ỨNG DỤNG:
```cpp
// Phép cộng số nguyên không dấu
struct UnsignedAddResult {
    int result;
    bool overflow;
};

UnsignedAddResult unsignedAdd(int a, int b, int bits) {
    int maxValue = (1 << bits) - 1;
    int sum = a + b;
    bool overflow = sum > maxValue;
    
    if (overflow) {
        sum = sum & maxValue; // Tương đương sum % (1 << bits)
    }
    
    return {sum, overflow};
}

// Kiểm tra tràn số
bool checkOverflow(int a, int b, int bits) {
    int maxValue = (1 << bits) - 1;
    return (a + b) > maxValue;
}
```

### ỨNG DỤNG THỰC TẾ:
- **Máy tính**: Unsigned arithmetic
- **Assembly**: ADD instruction với carry flag
- **Counters**: Loop counters, array indices
- **Memory addressing**: Address calculations
- **Hash functions**: Checksum calculations

---

**Tài liệu tham khảo:**
- Chương 2: Biểu diễn dữ liệu trên máy tính
- Phần 3.1: Biểu diễn số nguyên không dấu
